/**
 * Created by yevhen_chmykhun on 13.10.15.
 */
var constants = require('./../constants.json');
var util = require('./../util');

module.exports = function (gen, next) {

  var generator = gen, nextPrompt = next;

  var modelPrompt = function () {
    var modelPromptPromiseFunc = function (resolve, reject) {
      var modelPromptOptions = {
        type: 'input',
        name: 'model',
        message: 'Enter model name' + (generator.minContent ? "(empty field to proceed)" : ""),
        default: '',
        validate: util.validateName
      };
      var modelPromptCallback = function (answers) {
        if (answers.model != '') {
          var modelName = answers.model.capitalizeFirstLetter().makeCamelCase();
          generator.modelNames.push(modelName);
          generator.pureModelNames.push(modelName);
          generator.log(modelName);
          generator.models[modelName] = {};
          resolve(modelName)
        } else {
          generator.configObject['models'] = generator.models;
          util.saveConfig(generator.configObject, generator.configFileName);
          resolve(false)
        }
      };
      generator.prompt(modelPromptOptions, modelPromptCallback);
    };
    return new Promise(modelPromptPromiseFunc).then(afterModelPrompt);
  };


  var afterModelPrompt = function (modelName) {
    if (modelName) {
      return tableNamePrompt(modelName);
    } else {
      if (!generator.minContent) {
        generator.log('There must be minimum one model and minimum on column to proceed');
        return modelPrompt();
      }
      return nextPrompt ? nextPrompt() : false;
    }
  };


  var tableNamePrompt = function (modelName) {
    var tableNamePromptPromiseFunc = function (resolve, reject) {
      var tableNamePromptOptions = {
        type: 'input',
        name: 'table',
        message: 'Enter table name',
        default: modelName.toPlural().makeUnderscore(),
        filter: function (answer) {
          return answer.makeUnderscore();
        },
        validate: util.validateName
      };
      var tableNamePromptCallback = function (answers) {
        var tableName = answers.table;
        generator.log(tableName);
        generator.models[modelName].table = tableName;
        resolve(modelName);
      };
      generator.prompt(tableNamePromptOptions, tableNamePromptCallback);
    };
    return new Promise(tableNamePromptPromiseFunc).then(columnNamePrompt);
  };
  var columnNamePrompt = function (modelName) {
    if (typeof modelName == 'object') modelName = modelName.modelName;
    var columnNamePromptPromiseFunc = function (resolve, reject) {
      var columnNamePromptOptions = {
        type: 'input',
        name: 'column',
        message: 'Enter column name(empty field to proceed)',
        default: '',
        filter: function (answer) {
          return answer.makeUnderscore();
        },
        validate: util.validateColName
      };
      var columnNameCallback = function (answers) {
        if (!generator.models[modelName].columns) {
          generator.models[modelName].columns = {};
        }
        if (answers.column != '') {
          var columnName = answers.column.makeUnderscore();
          generator.log(columnName);
          var tableName = generator.models[modelName].table;
          generator.tableColumnsToFake.push(tableName + "." + columnName);
          generator.models[modelName].columns[columnName] = {};
          generator.minContent = true;
          resolve({modelName: modelName, columnName: columnName})
        } else {
          resolve({modelName: modelName, columnName: false})
        }
      };
      generator.prompt(columnNamePromptOptions, columnNameCallback);
    };
    return new Promise(columnNamePromptPromiseFunc).then(afterColumnNamePrompt);
  };


  var afterColumnNamePrompt = function (params) {

    if (!params.columnName) return indexesPrompt(params);
    else return columnTypePrompt(params);

  };


  var columnTypePrompt = function (params) {
    var launchStringTypePrompt = function (resolve) {
      var lengthPromptOptions = {
        type: 'input',
        name: 'fieldLength',
        message: 'Enter length',
        default: '255'
      };
      var lengthPromptCallback = function (answers) {
        generator.models[params.modelName].columns[params.columnName].length = parseInt(answers.fieldLength);
        resolve({modelName: params.modelName, columnName: params.columnName})
      };
      generator.prompt(lengthPromptOptions, lengthPromptCallback);
    };
    var launchIosTypeDatePrompt = function (resolve) {
      var iosTypeDatePromptOptions = {
        type: 'confirm',
        name: 'doIOSTypeDate',
        message: 'Set ios type as Date?',
        default: false
      };
      var iosTypeDatePromptCallback = function (answers) {
        generator.log(answers.doIOSTypeDate);
        if (answers.doIOSTypeDate) {
          generator.models[params.modelName].columns[params.columnName].iosType = "Date";
        }
        resolve({modelName: params.modelName, columnName: params.columnName})
      };
      generator.prompt(iosTypeDatePromptOptions, iosTypeDatePromptCallback);

    };
    var columnTypePromiseFunc = function (resolve, reject) {
      var columnTypePromptOptions = {
        type: 'list',
        name: 'type',
        message: 'Enter column type',
        choices: constants.columnTypes,
        default: constants.columnTypes[0]
      };

      var columnTypePromptCallback = function (answers) {
        var columnType = answers.type;
        generator.models[params.modelName].columns[params.columnName].type = columnType;
        switch (columnType) {
          case "STRING":
            launchStringTypePrompt(resolve);
            break;
          //case "INTEGER":
          //  launchIosTypeDatePrompt(resolve);
          //  break;
          case "DATE":
            //generator.models[params.modelName].columns[params.columnName].type = "INTEGER";
            generator.models[params.modelName].columns[params.columnName].iosType = "Date";
            resolve(params);
            break;
          default :
            resolve(params);
        }
      };
      generator.prompt(columnTypePromptOptions, columnTypePromptCallback);
    };
    return new Promise(columnTypePromiseFunc).then(columnAllowNullPrompt);
  };
  var indexesPrompt = function (params) {


    var indexesPromiseFunc = function (resolve, reject) {

      var selectAllowedFields = function (indexType) {
        var allowedFields = [];
        allowedFields.push("none");
        var fields = Object.keys(generator.models[params.modelName].columns);
        var i, fieldValue, restrictionName, rule, ruleFunction, allow, type;
        var indexRestrictions = constants.indexesRestrictions[indexType] || {};
        var restrictions = Object.keys(indexRestrictions);
        for (i = 0; i < fields.length; i++) {
          type = generator.models[params.modelName].columns[fields[i]].type;
          if (indexRestrictions[type]) {
            var restriction = Object.keys(indexRestrictions[type]);
            if (restriction.length) {
              restrictionName = indexRestrictions[type]["name"];
              fieldValue = generator.models[params.modelName].columns[fields[i]][restrictionName];
              rule = indexRestrictions[type]["rule"];
              ruleFunction = util.generateFunctionForRule(rule);
              allow = ruleFunction(indexRestrictions[type]["value"], fieldValue);
              if (allow) {
                allowedFields.push(fields[i])
              }
            }
          } else {
            allowedFields.push(fields[i])
          }
        }
        return allowedFields;
      };

      var indexSwitch = function (indexType, index) {
        switch (indexType) {
          case "unique":
            index.unique = true;

            var allowedFields = selectAllowedFields(indexType);


            var fieldNamesForIndex = [];
            var indexesFieldsPromptOptions = {
              type: 'list',
              name: 'fieldName',
              message: 'Add fields for unique index',
              choices: allowedFields,//fields,
              default: allowedFields[0],//fields[0]
            };
            var indexesFieldsPromptCallback = function (answer) {
              var fieldName = answer.fieldName;
              if (fieldName != "none") {
                fieldNamesForIndex.push(fieldName);
                generator.prompt(indexesFieldsPromptOptions, indexesFieldsPromptCallback);
              } else {
                index.fields = fieldNamesForIndex;
                generator.models[params.modelName].indexes.push(index);
                generator.prompt(indexesPromptOptions, indexesPromptCallback);
              }

            };
            generator.prompt(indexesFieldsPromptOptions, indexesFieldsPromptCallback);
            break;
          default :
            generator.log('How did i get here????');
            resolve(false);
        }
      }

      var indexesPromptOptions = {
        type: 'list',
        name: 'indexType',
        message: 'Add index',
        choices: constants.indexesType,
        default: constants.indexesType[0]
      };
      var indexesPromptCallback = function (answers) {
        var indexType = answers.indexType;
        if (indexType != "none") {
          if (!generator.models[params.modelName].indexes) generator.models[params.modelName].indexes = [];
          var index = {};
          indexSwitch(indexType, index);
        }
        else {
          resolve(false);
        }

      };
      generator.prompt(indexesPromptOptions, indexesPromptCallback);

    };
    return new Promise(indexesPromiseFunc).then(modelPrompt);
  };


  var columnAllowNullPrompt = function (params) {
    var columnAllowNullPromiseFunc = function (resolve, reject) {
      var columnAllowNullPromptOptions = {
        type: 'confirm',
        name: 'doNotAllowNull',
        message: 'Add NOT NULL constraint for this column?',
        default: false
      };
      var columnAllowNullPromptCallback = function (answers) {
        var modelName = params.modelName;
        var columnName = params.columnName;
        if (answers.doNotAllowNull)
          generator.models[modelName].columns[columnName].allowNull = !answers.doNotAllowNull;
        resolve(params);

      };
      generator.prompt(columnAllowNullPromptOptions, columnAllowNullPromptCallback);
    };
    return new Promise(columnAllowNullPromiseFunc).then(columnDoValidatePrompt);
  };

  var columnDoValidatePrompt = function (params) {
    var columnDoValidatePromiseFunc = function (resolve, reject) {
      var modelName = params.modelName;
      var columnName = params.columnName;
      var validationTypes = constants.constantsForTypes[generator.models[modelName].columns[columnName].type].fieldValidateTypes;
      if (validationTypes.length <= 0) {
        params.doValidate = false;
        resolve(params);
      } else {
        var columnDoValidatePromptOptions = {
          type: 'confirm',
          name: 'doValidate',
          message: 'Is there any validation rules?',
          default: false
        };
        var columnDoValidatePromptCallback = function (answers) {
          if (answers.doValidate) {
            generator.models[params.modelName].columns[params.columnName].validate = {};

          }
          params.doValidate = answers.doValidate;
          resolve(params);
        };
        generator.prompt(columnDoValidatePromptOptions, columnDoValidatePromptCallback);
      }
    };
    return new Promise(columnDoValidatePromiseFunc).then(columnValidationTypesPrompt);
  };
  var columnValidationTypesPrompt = function (params) {

    var isNotTypeAllowed = function (indexType) {
      var typeIsNotAllowed = false;
      var field = params.columnName;
      var i, fieldValue, restrictionName, rule, ruleFunction, allow, type;
      var indexRestrictions = constants.indexesRestrictions[indexType] || {};
      var restrictions = Object.keys(indexRestrictions);
      type = generator.models[params.modelName].columns[field].type;
      if (indexRestrictions[type]) {
        var restriction = Object.keys(indexRestrictions[type]);
        if (restriction.length) {
          restrictionName = indexRestrictions[type]["name"];
          fieldValue = generator.models[params.modelName].columns[field][restrictionName];
          rule = indexRestrictions[type]["rule"];
          ruleFunction = util.generateFunctionForRule(rule);
          allow = ruleFunction(fieldValue, indexRestrictions[type]["value"]);
          if (allow) {
            typeIsNotAllowed = true;
          }
        } else {
          typeIsNotAllowed = true;
        }
      }
      return typeIsNotAllowed;
    }
    var columnIsUniquePromiseFunc = function (resolve, reject) {
      var indexType = "unique";
      var typeIsNotAllowed = isNotTypeAllowed(indexType);
      if (typeIsNotAllowed) {
        resolve(params.modelName);
        return;
      }

      var columnIsUniquePromptOptions = {
        type: 'confirm',
        name: 'isUnique',
        message: 'Is this field unique?',
        default: false
      };
      var columnIsUniquePromptCallback = function (answers) {
        generator.models[params.modelName].columns[params.columnName].unique = answers.isUnique;
        resolve(params.modelName)
      };
      generator.prompt(columnIsUniquePromptOptions, columnIsUniquePromptCallback);
    };
    var columnIsUniqueOrValidationTypesPrompt = function () {
      if (params.loop)
        return new Promise(columnValidationTypesPromiseFunc).then(columnIsUniqueOrValidationTypesPrompt);
      return new Promise(columnIsUniquePromiseFunc).then(columnNamePrompt)
    };


    var columnValidationTypesPromiseFunc = function (resolve, reject) {
      var modelName = params.modelName;
      var columnName = params.columnName;

      function launchLengthValidationSetupPrompt() {
        var validationLenTypeOptions = {
          type: 'input',
          name: 'boundaryValues',
          message: 'Enter boundary values, separated be comma(Ex: 8,22)',
          default: '0,100'
        };
        var validationLenTypeCallback = function (answer) {
          var boundaryValues = answer.boundaryValues.split(',');
          boundaryValues.forEach(function (element, index) {
            boundaryValues[index] = parseInt(element);
          });
          generator.models[modelName].columns[columnName].validate.len = boundaryValues;
          resolve(params);
        };
        generator.prompt(validationLenTypeOptions, validationLenTypeCallback);
      }

      var columnValidationTypesPromptOptions = {
        type: 'list',
        name: 'validationType',
        message: 'Enter validation type(none to proceed)',
        choices: constants.constantsForTypes[generator.models[modelName].columns[columnName].type].fieldValidateTypes.concat("none"),
        default: constants.constantsForTypes[generator.models[modelName].columns[columnName].type].fieldValidateTypes[0]
      };
      var columnValidationTypesPromptCallback = function (answers) {

        switch (answers.validationType) {
          case 'none' :
            params.loop = false;
            resolve(params);
            break;
          case 'len':
            params.loop = true;
            generator.models[modelName].columns[columnName].validate.len = [];
            launchLengthValidationSetupPrompt();
            break;
          default :
            params.loop = true;
            generator.models[modelName].columns[columnName].validate[answers.validationType] = true;
            resolve(params);
        }


      };
      generator.prompt(columnValidationTypesPromptOptions, columnValidationTypesPromptCallback);
    };

    if (!params.doValidate) {
      return new Promise(columnIsUniquePromiseFunc).then(columnNamePrompt);
    } else {
      return new Promise(columnValidationTypesPromiseFunc).then(columnIsUniqueOrValidationTypesPrompt);
    }
  };


  return modelPrompt;
};
