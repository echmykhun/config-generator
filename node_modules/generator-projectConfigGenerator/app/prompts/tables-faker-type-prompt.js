/**
 * Created by yevhen_chmykhun on 13.10.15.
 */

var constants = require('./../constants.json');
var util = require('./../util');

module.exports = function (gen, next) {

  var generator = gen, nextPrompt = next;

  var tablesColumnsFakerTypePrompt = function () {
    var tablesColumnsFakerTypePromiseFunc = function (resolve, reject) {
      var filterSettedFakerFields = function (modelName) {
        var modelFields = [];
        var columns = Object.keys(generator.models[modelName].columns);
        modelFields.push("none");
        for (var i = 0; i < columns.length; i++) {
          if (generator.tableColumnsToFake.indexOf(generator.models[modelName].table + '.' + columns[i]) >= 0) {
            modelFields.push(columns[i]);
          }
        }
        return modelFields;
      };
      var tablesColumnsFakerTypePromptOptions = {
        type: 'list',
        name: 'model',
        message: 'TABLES COLUMNS FAKER TYPE \n Enter model name(none to proceed)',
        choices: generator.modelNames,
        default: generator.modelNames[0]
      };
      var tablesColumnsFakerTypePromptCallback = function (answers) {
        var modelName = answers.model;
        if (modelName != "none") {
          var modelFields = filterSettedFakerFields(modelName);
          resolve({modelName: modelName, modelFields: modelFields})
        } else {
          generator.configObject['tablesColumnsFakerType'] = generator.tablesColumnsFakerType;
          util.saveConfig(generator.configObject, generator.configFileName);
          resolve(false);
        }
      };
      generator.prompt(tablesColumnsFakerTypePromptOptions, tablesColumnsFakerTypePromptCallback);
    };
    return new Promise(tablesColumnsFakerTypePromiseFunc).then(afterTablesColumnsFakerTypePrompt);
  };

  var afterTablesColumnsFakerTypePrompt = function (params) {
    if (params) {
      return tablesColumnsFakerTypeModelFieldsPrompt(params);
    } else {
      if (generator.tableColumnsToFake.length > 0) {
        generator.log("You have to add faker type for all fields");
        return tablesColumnsFakerTypePrompt();
      }
      return nextPrompt ? nextPrompt() : false;
    }
  };


  var tablesColumnsFakerTypeModelFieldsPrompt = function (params) {
    var tablesColumnsFakerTypeModelFieldsPromiseFunc = function (resolve, reject) {
      var tablesColumnsFakerTypeModelFieldsPromptOptions = {
        type: 'list',
        name: 'field',
        message: 'Enter field name(none to proceed)',
        choices: params.modelFields,
        default: params.modelFields[0]
      };
      var tablesColumnsFakerTypeModelFieldsPromptCallback = function (answers) {
        if (answers.field != "none") {
          params.field = answers.field;
          resolve(params);
        } else {
          resolve(false);
        }
      };
      generator.prompt(tablesColumnsFakerTypeModelFieldsPromptOptions, tablesColumnsFakerTypeModelFieldsPromptCallback);
    };
    return new Promise(tablesColumnsFakerTypeModelFieldsPromiseFunc).then(afterTablesColumnsFakerTypeModelFieldsPrompt);
  };
  var afterTablesColumnsFakerTypeModelFieldsPrompt = function (params) {
    if (params) {
      return tablesColumnsFakerTypeModelFieldTypePrompt(params)
    } else {
      return tablesColumnsFakerTypePrompt();
    }
  };
  var tablesColumnsFakerTypeModelFieldTypePrompt = function (params) {

    var formAllowedFakerTypesVorFieldValidation = function (modelName, fieldName) {
      var allowedFakerTypesForFieldType = constants.constantsForTypes[generator.models[modelName].columns[fieldName].type].allowedFakerTypes;
      var fieldValidations = generator.models[modelName].columns[fieldName].validate || {};
      var fieldValidationNames = Object.keys(fieldValidations);
      var allowedFields = allowedFakerTypesForFieldType;
      var allowedFakerTypesVorValidations = constants.allowedFakerTypesVorValidations;
      for (var i = 0; i < fieldValidationNames.length; i++) {
        if (allowedFakerTypesVorValidations[fieldValidationNames[i]].FakerTypes.length > 0) {
          allowedFields = util.arrayIntersection(allowedFields, allowedFakerTypesVorValidations[fieldValidationNames[i]].FakerTypes);
        }
      }
      return allowedFields;
    };

    var tablesColumnsFakerTypeModelFieldTypePromiseFunc = function (resolve, reject) {
      var modelName = params.modelName;
      var fieldName = params.field;

      var allowedFields = formAllowedFakerTypesVorFieldValidation(modelName, fieldName);


      var addFakeType = function (type) {
        var tableName = generator.models[params.modelName].table;
        var columnName = params.field;
        if (!generator.tablesColumnsFakerType[tableName]) {
          generator.tablesColumnsFakerType[tableName] = {};
        }
        generator.tablesColumnsFakerType[tableName][columnName] = type;
        generator.tableColumnsToFake.splice(generator.tableColumnsToFake.indexOf(tableName + "." + columnName), 1);
        params.modelFields.splice(params.modelFields.indexOf(columnName), 1);

        //change temp types like DATE to the ones that must be in config
        //for now, it's the last and best point we can do it without full search
        util.replaceTempTypeToTrue(modelName, columnName, generator.models);
      };

      var runThroughValidations = function (validationsArray, fieldValidationNames, fieldValidations, substitution, i) {
        var fieldValidationValue;
        var validationValue;
        var isValidationPassed = true;
        for (var j = 0; j < validationsArray.length; j++) {
          if (fieldValidationNames[i] == validationsArray[j].name) {

            fieldValidationValue = fieldValidations[fieldValidationNames[i]];

            if (Number.isInteger(validationsArray[j].index) && fieldValidationValue[validationsArray[j].index]) {
              validationValue = fieldValidationValue[validationsArray[j].index];
            } else if (typeof validationsArray[j].index === 'undefined') {
              validationValue = fieldValidations[fieldValidationNames[i]];
            }
            if (validationValue) {
              var ruleSign = validationsArray[j].rule;
              var ruleFunction = util.generateFunctionForRule(ruleSign);
              isValidationPassed &= ruleFunction(substitution, validationValue);
            }
          }
        }
        return isValidationPassed
      }
      var validateSubstitution = function (substitutionName, substitution) {
        var isValidationPassed = true;
        var aliases = constants.FakerTypesSubstitutionAliases;
        var fieldValidations = generator.models[modelName].columns[fieldName].validate || {};

        var internalRestrictionNames = constants.constantsForTypes[generator.models[modelName].columns[fieldName].type].internalRestrictions || [];
        var restrictionName;
        for (var i = 0; i < internalRestrictionNames.length; i++) {
          restrictionName = aliases[internalRestrictionNames[i]] || internalRestrictionNames[i];
          if (generator.models[modelName].columns[fieldName][restrictionName]) {
            fieldValidations[restrictionName] = generator.models[modelName].columns[fieldName][restrictionName];
          }
        }

        var fieldValidationNames = Object.keys(fieldValidations);
        var fakerTypesSubstitutionsToValidationNames = constants.fakerTypesSubstitutionsToValidationNames;
        var fakerTypesSubstitutionsToInternalRestrictionNames = constants.fakerTypesSubstitutionsToInternalRestrictionNames;
        var validationSubstitutionName = fakerTypesSubstitutionsToValidationNames[substitutionName];
        var internalRestrictionSubstitutionName = fakerTypesSubstitutionsToInternalRestrictionNames[substitutionName];

        if (validationSubstitutionName && validationSubstitutionName.length > 0) {
          for (var i = 0; i < fieldValidationNames.length; i++) {
            isValidationPassed &= runThroughValidations(validationSubstitutionName, fieldValidationNames, fieldValidations, substitution, i);
            isValidationPassed &= runThroughValidations(internalRestrictionSubstitutionName, fieldValidationNames, fieldValidations, substitution, i);
          }
        }
        return isValidationPassed;
      };
      var tablesColumnsFakerTypeModelFieldTypePromptOptions = {
        type: 'list',
        name: 'fieldType',
        message: 'Enter field type',
        choices: allowedFields,//allowedFakerTypesForFieldType,
        default: allowedFields[0]//allowedFakerTypesForFieldType
      };
      var tablesColumnsFakerTypeModelFieldTypePromptCallback = function (answer) {
        var type = answer.fieldType;
        var substitutionRule = constants.allowedFakerTypesSubstitutionRule;
        var substitutionRegExp = new RegExp(substitutionRule);
        if (substitutionRegExp.test(type)) {
          var substitutionNames = substitutionRegExp.exec(type);
          var substitutionName = substitutionNames[1];
          var allowedFakerTypesSubstitutionOptions = {
            type: 'input',
            name: substitutionName,
            message: 'Enter ' + substitutionName,
            default: '10'
          };
          var allowedFakerTypesSubstitutionCallback = function (answer) {
            var substitution = parseInt(answer[substitutionName]);
            var isValidationPassed = validateSubstitution(substitutionName, substitution);
            if (isValidationPassed) {
              type = type.replace(substitutionRegExp, "(" + substitution + ")");
              addFakeType(type);
            } else {
              generator.log('Value does not pass validations for this field');
            }
            resolve(params);
          };
          generator.prompt(allowedFakerTypesSubstitutionOptions, allowedFakerTypesSubstitutionCallback);

        } else {
          addFakeType(type);
          resolve(params);
        }


      };
      generator.prompt(tablesColumnsFakerTypeModelFieldTypePromptOptions, tablesColumnsFakerTypeModelFieldTypePromptCallback);
    };
    return new Promise(tablesColumnsFakerTypeModelFieldTypePromiseFunc).then(tablesColumnsFakerTypeModelFieldsPrompt);
  };

  return tablesColumnsFakerTypePrompt;
};