/**
 * Created by yevhen_chmykhun on 29.09.15.
 */
var generators = require('yeoman-generator');
var fs = require('fs');
var constants = require('./constants.json');

var configFileName = 'someConfig.json';

var configObject = {};
var models = {};
var relationships = {};
var modelsCrudMethods = {};
var tablesColumnsFakerType = {};
var onlyServerFields = {};
var updateModelsAllowedAttrs = {};
var serverConfig = {};
var iosConfig = {};

var modelNames = [];
var pureModelNames = [];
var relTypes = [];

var tableColumnsToFake = [];

modelNames.push("none");
for (var relationIndex = 0; relationIndex < constants.relationshipsTypes.length; relationIndex++) {
  relTypes.push(constants.relationshipsTypes[relationIndex]);
  relationships[constants.relationshipsTypes[relationIndex]] = [];
}
relTypes.push("none");

String.prototype.capitalizeFirstLetter = function () {
  return this.charAt(0).toUpperCase() + this.slice(1);
};
String.prototype.makeCamelCase = function () {
  return this.replace(/(_|-|\s)([a-z])/g, function (g) {
    return g[1].toUpperCase();
  });
};

var saveConfig = function () {
  fs.writeFileSync(configFileName, JSON.stringify(configObject, null, 2), 'utf8');
};

//to make relation structure more convenient for CRUD creation
var modelOrientedRelations = {};
var addModelOrientedRelation = function (params) {
  initModelOrientedRelation(params);
  var ownerClassName = params.relationship.ownerClassName;
  var ownedClassName = params.relationship.ownedClassName;
  var relationType = params.rel;
  //owned
  modelOrientedRelations[ownerClassName][relationType]['owned'].push(ownedClassName);
  //owner
  modelOrientedRelations[ownedClassName][relationType]['owner'].push(ownerClassName);


};
var initModelOrientedRelation = function (params) {
  initModelOrientedRelationRole(params, 'owner');
  initModelOrientedRelationRole(params, 'owned');
};
var initModelOrientedRelationRole = function (params, role) {
  var roleClassName = params.relationship[role + 'ClassName'];
  var relationType = params.rel;
  if (!modelOrientedRelations[roleClassName])
    modelOrientedRelations[roleClassName] = {};
  if (!modelOrientedRelations[roleClassName][relationType])
    modelOrientedRelations[roleClassName][relationType] = {};

  if (!modelOrientedRelations[roleClassName][relationType]['owner'])
    modelOrientedRelations[roleClassName][relationType]['owner'] = [];
  if (!modelOrientedRelations[roleClassName][relationType]['owned'])
    modelOrientedRelations[roleClassName][relationType]['owned'] = [];
};

var InjectCRUDModelNames = function (params, type) {
  params[type] = params[type] || {};
  try {
    if (params[type].isCRUDModelNamesInjected) return;
    var i, j, k;
    var hints = constants.CRUDRelationTypesHints[type + 'NestedModels'];
    var hintRelRoles = Object.keys(hints);
    var allowedRelTypes = [];
    var modelsForInsertion = {};
    var allowedModels = ["none"];
    var currentModels = [];

    //role - owner or owned for relation
    for (i = 0; i < hintRelRoles.length; i++) {
      allowedRelTypes = Object.keys(hints[hintRelRoles[i]]);
      for (j = 0; j < allowedRelTypes.length; j++) {
        if (modelOrientedRelations[params.modelName]
            && modelOrientedRelations[params.modelName][allowedRelTypes[j]]
            && modelOrientedRelations[params.modelName][allowedRelTypes[j]][hintRelRoles[i]]) {
          currentModels = modelOrientedRelations[params.modelName][allowedRelTypes[j]][hintRelRoles[i]];
          for (k = 0; k < currentModels.length; k++) {
            if (currentModels[k]) {
              if (hints[hintRelRoles[i]] && hints[hintRelRoles[i]][allowedRelTypes[j]]) {
                modelsForInsertion[currentModels[k]] = hints[hintRelRoles[i]][allowedRelTypes[j]];
                allowedModels.push(currentModels[k]);
              }
            }
          }
        }
      }
    }
    params[type].isCRUDModelNamesInjected = true;
    params[type].modelsForInsertion = modelsForInsertion;
    params[type].allowedModels = allowedModels;
  } catch (err) {
    console.log('err in InjectCRUDModelNames: ', err);
  }

};
var generatorObject = {

  constructor: function () {
    generators.Base.apply(this, arguments);
    this.option('configFileName');
    this.option('edit');
  },

  init: function () {

    var optionEdit = this.options.edit;
    var optionConfigFileName = this.options.configFileName;
    var configConfigFileName = this.config.get('configFileName');

    if(optionConfigFileName.indexOf(".json") < 0 && optionConfigFileName.indexOf(".JSON") < 0){
      optionConfigFileName += ".json";
    }

    configFileName = optionConfigFileName || configConfigFileName || configFileName;
    if (!configConfigFileName || configFileName != configConfigFileName)
      this.config.set('configFileName', configFileName);


    this.config.save();

    if (fs.existsSync(this.destinationPath(configFileName)) && optionEdit) {

      configObject = require(this.destinationPath(configFileName));
      models = configObject.models || {};
      relationships = configObject.relationships || {};
      modelsCrudMethods = configObject.modelsCrudMethods || {};
      tablesColumnsFakerType = configObject.tablesColumnsFakerType || {};
      onlyServerFields = configObject.onlyServerFields || {};
      updateModelsAllowedAttrs = configObject.updateModelsAllowedAttrs || {};
      serverConfig = configObject.serverConfig || {};
      iosConfig = configObject.iosConfig || {};
      if (models) {
        pureModelNames = Object.keys(models);
        modelNames = Object.keys(models);
        modelNames.push("none");
      }

      if (Object.getOwnPropertyNames(relationships).length === 0) {
        for (var i = 0; i < constants.relationshipsTypes.length; i++) {

          relationships[constants.relationshipsTypes[i]] = [];
        }
      }

    }


  },

  prompting: function () {
    var _this = this;


    var generalPrompt = function (resolve, reject) {
      var generalPromptOptions = {
        type: 'input',
        name: 'name',
        message: "Wellcome to config generator. \n Enter your app name and press Enter to start",
        default: configObject.appName || "GeneratedProject"
      };
      var generalPromptCallback = function (answers) {
        configObject.appName = answers.name.capitalizeFirstLetter().makeCamelCase();
        saveConfig();
        resolve();
      };
      _this.prompt(generalPromptOptions, generalPromptCallback);
    };

//==========================MODELS======================================
    var modelPromptPromiseFunc = function (resolve, reject) {
      var modelPromptOptions = {
        type: 'input',
        name: 'model',
        message: 'Enter model name',
        default: ''
      };
      var modelPromptCallback = function (answers) {
        if (answers.model != '') {
          var modelName = answers.model.capitalizeFirstLetter().makeCamelCase();
          modelNames.push(modelName);
          pureModelNames.push(modelName);
          _this.log(modelName);
          models[modelName] = {};
          resolve(modelName)
        } else {
          configObject['models'] = models;
          saveConfig();
          resolve(false)
        }
      };
      _this.prompt(modelPromptOptions, modelPromptCallback);
    };
    var modelPrompt = function (val) {
      return new Promise(modelPromptPromiseFunc).then(afterModelPrompt);
    };
    var afterModelPrompt = function (modelName) {
      if (modelName) {
        return tableNamePrompt(modelName);
      } else {
        return relationsPrompt();
      }
    };
    var tableNamePrompt = function (modelName) {
      var tableNamePromptPromiseFunc = function (resolve, reject) {
        var tableNamePromptOptions = {
          type: 'input',
          name: 'table',
          message: 'Enter table name',
          default: modelName.toLowerCase() + 's'
        };
        var tableNamePromptCallback = function (answers) {
          var tableName = answers.table;
          models[modelName].table = tableName;
          resolve(modelName);
        };
        _this.prompt(tableNamePromptOptions, tableNamePromptCallback);
      };
      return new Promise(tableNamePromptPromiseFunc).then(columnNamePrompt);
    };
    var columnNamePrompt = function (modelName) {
      if (typeof modelName == 'object') modelName = modelName.modelName;
      var columnNamePromptPromiseFunc = function (resolve, reject) {
        var columnNamePromptOptions = {
          type: 'input',
          name: 'column',
          message: 'Enter column name',
          default: ''
        };
        var columnNameCallback = function (answers) {
          if (!models[modelName].columns) {
            models[modelName].columns = {};
          }
          if (answers.column != '') {
            var columnName = answers.column;
            var tableName = models[modelName].table;
            tableColumnsToFake.push(tableName + "." + columnName);
            models[modelName].columns[columnName] = {};
            resolve({modelName: modelName, columnName: columnName})
          } else {
            resolve({modelName: modelName, columnName: false})
          }
        };
        _this.prompt(columnNamePromptOptions, columnNameCallback);
      };
      return new Promise(columnNamePromptPromiseFunc).then(afterColumnNamePrompt);
    };
    var afterColumnNamePrompt = function (params) {
      var launchStringTypePrompt = function (resolve) {
        var lengthPromptOptions = {
          type: 'input',
          name: 'fieldLength',
          message: 'Enter length',
          default: '255'
        };
        var lengthPromptCallback = function (answers) {
          models[params.modelName].columns[params.columnName].length = parseInt(answers.fieldLength);
          resolve({modelName: params.modelName, columnName: params.columnName})
        };
        _this.prompt(lengthPromptOptions, lengthPromptCallback);
      };
      var launchIosTypeDatePrompt = function (resolve) {
        var iosTypeDatePromptOptions = {
          type: 'confirm',
          name: 'doIOSTypeDate',
          message: 'Set ios type as Date?',
          default: false
        };
        var iosTypeDatePromptCallback = function (answers) {
          _this.log(answers.doIOSTypeDate);
          if (answers.doIOSTypeDate) {
            models[params.modelName].columns[params.columnName].iosType = "Date";
          }
          resolve({modelName: params.modelName, columnName: params.columnName})
        };
        _this.prompt(iosTypeDatePromptOptions, iosTypeDatePromptCallback);

      };
      var columnTypePromiseFunc = function (resolve, reject) {
        var columnTypePromptOptions = {
          type: 'list',
          name: 'type',
          message: 'Enter column type',
          choices: constants.columnTypes,
          default: constants.columnTypes[0]
        };

        var columnTypePromptCallback = function (answers) {
          var columnType = answers.type;
          models[params.modelName].columns[params.columnName].type = columnType;
          switch (columnType) {
            case "STRING":
              launchStringTypePrompt(resolve);
              break;
            case "INTEGER":
              launchIosTypeDatePrompt(resolve);
              break;
            default :
              resolve(params);
          }
        };
        _this.prompt(columnTypePromptOptions, columnTypePromptCallback);
      };
      var indexesPromiseFunc = function (resolve, reject) {
        function indexSwitch(indexType, index) {
          switch (indexType) {
            case "unique":
              index.unique = true;
              var fields = Object.keys(models[params.modelName].columns);
              fields.push("none");
              var fieldNamesForIndex = [];
              var indexesFieldsPromptOptions = {
                type: 'list',
                name: 'fieldName',
                message: 'Add fields for unique index',
                choices: fields,
                default: fields[0]
              };
              var indexesFieldsPromptCallback = function (answer) {
                var fieldName = answer.fieldName;
                if (fieldName != "none") {
                  fieldNamesForIndex.push(fieldName);
                  _this.prompt(indexesFieldsPromptOptions, indexesFieldsPromptCallback);
                } else {
                  index.fields = fieldNamesForIndex;
                  models[params.modelName].indexes.push(index);
                  _this.prompt(indexesPromptOptions, indexesPromptCallback);
                }

              };
              _this.prompt(indexesFieldsPromptOptions, indexesFieldsPromptCallback);
              break;
            default :
              _this.log('How did i get here????');
              resolve(false);
          }
        }

        var indexesPromptOptions = {
          type: 'list',
          name: 'indexType',
          message: 'Add index',
          choices: constants.indexesType,
          default: constants.indexesType[0]
        };
        var indexesPromptCallback = function (answers) {
          var indexType = answers.indexType;
          if (indexType != "none") {
            if (!models[params.modelName].indexes) models[params.modelName].indexes = [];
            var index = {};
            indexSwitch(indexType, index);
          }
          else {
            resolve(false);
          }

        };
        _this.prompt(indexesPromptOptions, indexesPromptCallback);

      };
      if (!params.columnName) return new Promise(indexesPromiseFunc).then(modelPrompt);
      return new Promise(columnTypePromiseFunc).then(columnDoValidatePrompt);
    };
    var columnDoValidatePrompt = function (params) {
      var columnDoValidatePromiseFunc = function (resolve, reject) {
        var columnDoValidatePromptOptions = {
          type: 'confirm',
          name: 'doValidate',
          message: 'Is there any validation rules?',
          default: false
        };
        var columnDoValidatePromptCallback = function (answers) {
          if (answers.doValidate) {
            models[params.modelName].columns[params.columnName].validate = {};

          }
          resolve({
            modelName: params.modelName,
            columnName: params.columnName,
            doValidate: answers.doValidate
          });
        };
        _this.prompt(columnDoValidatePromptOptions, columnDoValidatePromptCallback);
      };
      return new Promise(columnDoValidatePromiseFunc).then(columnValidationTypesPrompt);
    };
    var columnValidationTypesPrompt = function (params) {

      var columnIsUniquePromiseFunc = function (resolve, reject) {
        var columnIsUniquePromptOptions = {
          type: 'confirm',
          name: 'isUnique',
          message: 'Is this field unique?',
          default: false
        };
        var columnIsUniquePromptCallback = function (answers) {
          models[params.modelName].columns[params.columnName].unique = answers.isUnique;
          resolve(params.modelName)
        };
        _this.prompt(columnIsUniquePromptOptions, columnIsUniquePromptCallback);
      };
      var columnIsUniquePrompt = function (params) {
        return new Promise(columnIsUniquePromiseFunc).then(columnNamePrompt)
      };


      var columnValidationTypesPromiseFunc = function (resolve, reject) {
        var modelName = params.modelName;
        var columnName = params.columnName;

        function launchLengthValidationSetupPrompt() {
          var validationLenTypeOptions = {
            type: 'input',
            name: 'boundaryValues',
            message: 'Enter boundary values, separated be comma(Ex: 8,22)',
            default: '0,100'
          };
          var validationLenTypeCallback = function (answer) {
            var boundaryValues = answer.boundaryValues.split(',');
            boundaryValues.forEach(function (element, index) {
              boundaryValues[index] = parseInt(element);
            });
            models[modelName].columns[columnName].validate.len = boundaryValues;
            resolve(params);
          };
          _this.prompt(validationLenTypeOptions, validationLenTypeCallback);
        }

        var columnValidationTypesPromptOptions = {
          type: 'list',
          name: 'validationType',
          message: 'Enter validation type',
          choices: constants.constantsForTypes[models[modelName].columns[columnName].type].fieldValidateTypes.concat("none"),
          default: constants.constantsForTypes[models[modelName].columns[columnName].type].fieldValidateTypes[0]
        };
        var columnValidationTypesPromptCallback = function (answers) {

          switch (answers.validationType) {
            case 'len':
              models[modelName].columns[columnName].validate.len = [];
              launchLengthValidationSetupPrompt();
              break;
            case 'isInt':
              models[modelName].columns[columnName].validate.isInt = true;
              resolve(params);
              break;
            default :
              _this.log('You should be more careful!');
              resolve(params);
          }


        };
        _this.prompt(columnValidationTypesPromptOptions, columnValidationTypesPromptCallback);
      };

      if (!params.doValidate) {
        return new Promise(columnIsUniquePromiseFunc).then(columnNamePrompt);
      } else {

        return new Promise(columnValidationTypesPromiseFunc).then(columnIsUniquePrompt);
      }

      //return new Promise(columnValidationTypesPromiseFunc);//.then(columnIsUniquePrompt);
    };

//========================RELATIONS================
    var relationsPrompt = function () {
      var relationsPromptPromiseFunc = function (resolve, reject) {
        var relationsPromptOptions = {
          type: 'list',
          name: 'type',
          message: 'Enter relationship type',
          choices: relTypes,
          default: relTypes[0]
        };
        var relationsPromptCallback = function (answers) {
          var rel = answers.type;
          if (rel == "none") {
            configObject['relationships'] = relationships;
            saveConfig();
          }
          resolve(rel);
        };
        _this.prompt(relationsPromptOptions, relationsPromptCallback);

      };
      return new Promise(relationsPromptPromiseFunc).then(afterRelationsPrompt);
    };
    var afterRelationsPrompt = function (rel) {
      if (rel != "none") {
        var params = {rel: rel};
        return ownerClassPropPrompt(params);
      } else {
        return modelsCRUDMethodsPrompt();
      }
    };
    var ownerClassPropPrompt = function (params) {
      var ownerClassPropPromiseFunc = function (resolve, reject) {
        var ownerClassPropPromptOptions = {
          type: 'list',
          name: 'ownerClassName',
          message: 'Enter owner class name',
          choices: pureModelNames,
          default: pureModelNames[0]
        };
        var ownerClassPropPromptCallback = function (answers) {
          params.relationship = {};
          params.relationship.ownerClassName = answers.ownerClassName;
          resolve(params)
        };
        _this.prompt(ownerClassPropPromptOptions, ownerClassPropPromptCallback);

      };
      return new Promise(ownerClassPropPromiseFunc).then(ownedClassPropPrompt);
    };
    var ownedClassPropPrompt = function (params) {
      var ownedClassPropPromiseFunc = function (resolve, reject) {
        var ownedClassPropPromptOptions = {
          type: 'list',
          name: 'ownedClassName',
          message: 'Enter owned class name',
          choices: pureModelNames,
          default: pureModelNames[0]
        };
        var ownedClassPropPromptCallback = function (answers) {
          params.relationship.ownedClassName = answers.ownedClassName;
          addModelOrientedRelation(params);
          resolve(params)
        };
        _this.prompt(ownedClassPropPromptOptions, ownedClassPropPromptCallback);

      };
      return new Promise(ownedClassPropPromiseFunc).then(deleteOwnerConstraintsPrompt);
    };
    var deleteOwnerConstraintsPrompt = function (params) {
      var deleteOwnerConstraintsPromiseFunc = function (resolve, reject) {
        var deleteOwnerConstraintsPromptOptions = {
          type: 'list',
          name: 'onDeleteOwnerConstraint',
          message: 'delete owner constraint',
          choices: constants.onDeleteOwnerConstraints,
          default: constants.onDeleteOwnerConstraints[0]
        };
        var deleteOwnerConstraintsPromptCallback = function (answers) {
          params.relationship.onDeleteOwnerConstraint = answers.onDeleteOwnerConstraint;
          relationships[params.rel].push(params.relationship);
          resolve(false);
        };

        _this.prompt(deleteOwnerConstraintsPromptOptions, deleteOwnerConstraintsPromptCallback);
      };
      return new Promise(deleteOwnerConstraintsPromiseFunc).then(relationsPrompt);
    };

//==========================CRUD============

    var modelsCRUDMethodsPrompt = function () {
      var modelsCRUDMethodsPromiseFunc = function (resolve, reject) {
        var modelsCRUDMethodsPromptOptions = {
          type: 'list',
          name: 'model',
          message: 'Enter model for CRUD',
          choices: modelNames,
          default: modelNames[0]
        };
        var modelsCRUDMethodsPromptOptionsCallback = function (answers) {
          var modelName = answers.model;
          if (modelName == "none") {
            configObject['modelsCrudMethods'] = modelsCrudMethods;
            saveConfig();
            resolve(false);
          }
          else {
            resolve({modelName: modelName})
          }
        };
        _this.prompt(modelsCRUDMethodsPromptOptions, modelsCRUDMethodsPromptOptionsCallback);
      };
      return new Promise(modelsCRUDMethodsPromiseFunc).then(afterModelsCRUDMethodsPrompt);
    };
    var afterModelsCRUDMethodsPrompt = function (params) {
      if (params) {
        return CRUDMethodsPrompt(params);
      } else {
        return onlyServerFieldsPrompt();
      }
    };
    var CRUDMethodsPrompt = function (params) {
      var CRUDMethodsPromiseFunc = function (resolve, reject) {
        var CRUDMethodsPromptOptions = {
          type: 'list',
          name: 'methodNameKey',
          message: 'Enter method for CRUD',
          choices: constants.modelsCrudMethodsKeys,
          default: constants.modelsCrudMethodsKeys[0]
        };
        var CRUDMethodsPromptCallback = function (answers) {
          var methodNameKey = answers.methodNameKey;
          if (!modelsCrudMethods[params.modelName])modelsCrudMethods[params.modelName] = {};
          if (methodNameKey != "none") {
            if (!modelsCrudMethods[params.modelName]) modelsCrudMethods[params.modelName] = {};
            var methodName = constants.modelsCrudMethods[methodNameKey];
            modelsCrudMethods[params.modelName][methodName] = {};
            params.methodName = methodName;
            resolve(params);
          } else {
            resolve(false);
          }
        };
        _this.prompt(CRUDMethodsPromptOptions, CRUDMethodsPromptCallback);
      };
      return new Promise(CRUDMethodsPromiseFunc).then(afterCRUDMethodsPrompt);
    };
    var afterCRUDMethodsPrompt = function (params) {
      if (!params) {
        return modelsCRUDMethodsPrompt();
      } else {
        return requestNestedModelsPrompt(params);
      }
    };

    var nestedModelsPromiseFuncGenerator = function (params, type) {
      return function (resolve, reject) {
        if (!modelsCrudMethods[params.modelName][params.methodName][type + "NestedModels"]) {
          modelsCrudMethods[params.modelName][params.methodName][type + "NestedModels"] = {}
        }
        if (params.methodName == "DELETE" || (params.methodName == "GET" && type == "request")) {
          params[type + "NestedModelName"] = "none";
          resolve(params);
          return;
        }
        InjectCRUDModelNames(params, type);
        var requestNestedModelsPromptOptions = {
          type: 'list',
          name: 'model',
          message: 'Enter ' + type + ' nested Model',
          choices: params[type].allowedModels,
          default: params[type].allowedModels[0]
        };
        var requestNestedModelsPromptCallback = function (answers) {
          params[type + "NestedModelName"] = answers.model;
          if (params[type + "NestedModelName"] != "none") {
            modelsCrudMethods[params.modelName]
                [params.methodName]
                [type + "NestedModels"]
                [answers.model] = params[type].modelsForInsertion[answers.model];
          }
          resolve(params);
        };
        _this.prompt(requestNestedModelsPromptOptions, requestNestedModelsPromptCallback);
      };
    };

    var requestNestedModelsPrompt = function (params) {
      var requestNestedModelsPromiseFunc = nestedModelsPromiseFuncGenerator(params, "request");
      return new Promise(requestNestedModelsPromiseFunc).then(afterRequestNestedModelsPromiseFunc);
    };
    var afterRequestNestedModelsPromiseFunc = function (params) {
      if (params.requestNestedModelName != "none") {
        //return requestModelCRUDDataTypePrompt(params)
        return requestNestedModelsPrompt(params);
      } else {
        return responseNestedModelsPrompt(params);
      }
    };
    var requestModelCRUDDataTypePrompt = function (params) {
      var requestModelCRUDDataTypePromiseFunction = function (resolve, reject) {
        var requestModelCRUDDataTypePromptOptions = {
          type: 'list',
          name: 'modelType',
          message: 'Enter request nested model type',
          choices: constants.CRUDModelsTypes,
          default: constants.CRUDModelsTypes[0]
        };
        var requestModelCRUDDataTypePromptCallback = function (answers) {
          modelsCrudMethods[params.modelName][params.methodName]["requestNestedModels"][params.requestNestedModelName] = answers.modelType;
          resolve(params);
        };
        _this.prompt(requestModelCRUDDataTypePromptOptions, requestModelCRUDDataTypePromptCallback);
      };
      return new Promise(requestModelCRUDDataTypePromiseFunction).then(requestNestedModelsPrompt);
    };
    var responseNestedModelsPrompt = function (params) {
      var responseNestedModelsPromiseFunc = nestedModelsPromiseFuncGenerator(params, "response");
      return new Promise(responseNestedModelsPromiseFunc).then(afterResponseNestedModelsPromiseFunc);
    };
    var afterResponseNestedModelsPromiseFunc = function (params) {
      if (params.responseNestedModelName != "none") {
        //return responseModelCRUDDataTypePrompt(params)
        return responseNestedModelsPrompt(params)
      } else {
        return modelsCRUDMethodsPrompt(params);
      }
    };
    var responseModelCRUDDataTypePrompt = function (params) {
      var responseModelCRUDDataTypePromiseFunction = function (resolve, reject) {
        var responseModelCRUDDataTypePromptOptions = {
          type: 'list',
          name: 'modelType',
          message: 'Enter response nested model type',
          choices: constants.CRUDModelsTypes,
          default: constants.CRUDModelsTypes[0]
        };
        var responseModelCRUDDataTypePromptCallback = function (answers) {
          modelsCrudMethods[params.modelName][params.methodName]["responseNestedModels"][params.responseNestedModelName] = answers.modelType;
          resolve(params);
        };
        _this.prompt(responseModelCRUDDataTypePromptOptions, responseModelCRUDDataTypePromptCallback);
      };
      return new Promise(responseModelCRUDDataTypePromiseFunction).then(responseNestedModelsPrompt);
    };

//==========================ONLY SERVER FIELD=======================


    var onlyServerFieldsPrompt = function () {
      var onlyServerFieldsPromiseFunc = function (resolve, reject) {
        var onlyServerFieldsPromptOptions = {
          type: 'list',
          name: 'model',
          message: 'Only server fields \n Enter model name',
          choices: modelNames,
          default: modelNames[0]
        };
        var onlyServerFieldsPromptCallback = function (answers) {
          var modelName = answers.model;
          if (modelName != "none") {
            tablesColumnsFakerType[modelName] = {};
            var modelFields = Object.keys(models[modelName].columns);
            modelFields.push("none");
            resolve({modelName: modelName, modelFields: modelFields})
          } else {
            configObject['onlyServerFields'] = onlyServerFields;
            saveConfig();
            resolve(false);
          }
        };
        _this.prompt(onlyServerFieldsPromptOptions, onlyServerFieldsPromptCallback);
      };
      return new Promise(onlyServerFieldsPromiseFunc).then(afterOnlyServerFieldsPrompt);
    };
    var afterOnlyServerFieldsPrompt = function (params) {
      if (params) {
        return onlyServerFieldsModelFieldsPrompt(params);
      } else {
        return tablesColumnsFakerTypePrompt();
      }
    };
    var onlyServerFieldsModelFieldsPrompt = function (params) {
      var onlyServerFieldsModelFieldsPromiseFunc = function (resolve, reject) {
        var onlyServerFieldsModelFieldsPromptOptions = {
          type: 'list',
          name: 'field',
          message: 'Enter field name',
          choices: params.modelFields,
          default: params.modelFields[0]
        };
        var onlyServerFieldsModelFieldsPromptCallback = function (answer) {
          var field = answer.field;
          params.field = field;
          if (field != "none") {
            if (!onlyServerFields[params.modelName])onlyServerFields[params.modelName] = [];
            onlyServerFields[params.modelName].push(field);
          }
          resolve(params);
        };
        _this.prompt(onlyServerFieldsModelFieldsPromptOptions, onlyServerFieldsModelFieldsPromptCallback);
      };
      return new Promise(onlyServerFieldsModelFieldsPromiseFunc).then(afterOnlyServerFieldsModelFieldsPrompt);
    };
    var afterOnlyServerFieldsModelFieldsPrompt = function (params) {
      if (params.field != "none") {
        return onlyServerFieldsModelFieldsPrompt(params);
      } else {
        return onlyServerFieldsPrompt();
      }
    };

//==========================TABLES COLUMNS FAKER TYPE================

    var tablesColumnsFakerTypePrompt = function () {
      var tablesColumnsFakerTypePromiseFunc = function (resolve, reject) {
        var filterSettedFakerFields = function (modelName) {
          var modelFields = [];
          var columns = Object.keys(models[modelName].columns);
          modelFields.push("none");
          for (var i = 0; i < columns.length; i++) {
            if (tableColumnsToFake.indexOf(models[modelName].table + '.' + columns[i]) >= 0) {
              modelFields.push(columns[i]);
            }
          }
          return modelFields;
        };
        var tablesColumnsFakerTypePromptOptions = {
          type: 'list',
          name: 'model',
          message: 'TABLES COLUMNS FAKER TYPE \n Enter model name',
          choices: modelNames,
          default: modelNames[0]
        };
        var tablesColumnsFakerTypePromptCallback = function (answers) {
          var modelName = answers.model;
          if (modelName != "none") {
            var modelFields = filterSettedFakerFields(modelName);
            resolve({modelName: modelName, modelFields: modelFields})
          } else {
            configObject['tablesColumnsFakerType'] = tablesColumnsFakerType;
            saveConfig();
            resolve(false);
          }
        };
        _this.prompt(tablesColumnsFakerTypePromptOptions, tablesColumnsFakerTypePromptCallback);
      };
      return new Promise(tablesColumnsFakerTypePromiseFunc).then(afterTablesColumnsFakerTypePrompt);
    };
    var afterTablesColumnsFakerTypePrompt = function (params) {
      if (params) {
        return tablesColumnsFakerTypeModelFieldsPrompt(params);
      } else {
        if (tableColumnsToFake.length > 0) {
          _this.log("You have to add faker type for all fields");
          return tablesColumnsFakerTypePrompt();
        }
        return updateModelsAllowedAttrsPrompt();
      }
    };
    var tablesColumnsFakerTypeModelFieldsPrompt = function (params) {
      var tablesColumnsFakerTypeModelFieldsPromiseFunc = function (resolve, reject) {
        var tablesColumnsFakerTypeModelFieldsPromptOptions = {
          type: 'list',
          name: 'field',
          message: 'Enter field name',
          choices: params.modelFields,
          default: params.modelFields[0]
        };
        var tablesColumnsFakerTypeModelFieldsPromptCallback = function (answers) {
          if (answers.field != "none") {
            params.field = answers.field;
            resolve(params);
          } else {
            resolve(false);
          }
        };
        _this.prompt(tablesColumnsFakerTypeModelFieldsPromptOptions, tablesColumnsFakerTypeModelFieldsPromptCallback);
      };
      return new Promise(tablesColumnsFakerTypeModelFieldsPromiseFunc).then(afterTablesColumnsFakerTypeModelFieldsPrompt);
    };
    var afterTablesColumnsFakerTypeModelFieldsPrompt = function (params) {
      if (params) {
        return tablesColumnsFakerTypeModelFieldTypePrompt(params)
      } else {
        return tablesColumnsFakerTypePrompt();
      }
    };
    var tablesColumnsFakerTypeModelFieldTypePrompt = function (params) {
      var tablesColumnsFakerTypeModelFieldTypePromiseFunc = function (resolve, reject) {
        var modelName = params.modelName;
        var fieldName = params.field;
        var allowedFakerTypesForFieldType = constants.constantsForTypes[models[modelName].columns[fieldName].type].allowedFakerTypes;
        var addFakeType = function (type) {
          var tableName = models[params.modelName].table;
          var columnName = params.field;
          if (!tablesColumnsFakerType[tableName]) {
            tablesColumnsFakerType[tableName] = {};
          }
          tablesColumnsFakerType[tableName][columnName] = type;
          tableColumnsToFake.splice(tableColumnsToFake.indexOf(tableName + "." + columnName), 1);
          params.modelFields.splice(params.modelFields.indexOf(columnName), 1);

        };
        var tablesColumnsFakerTypeModelFieldTypePromptOptions = {
          type: 'list',
          name: 'fieldType',
          message: 'Enter field type',
          choices: allowedFakerTypesForFieldType,
          default: allowedFakerTypesForFieldType
        };
        var tablesColumnsFakerTypeModelFieldTypePromptCallback = function (answer) {
          var type = answer.fieldType;
          var substitutionRule = constants.allowedFakerTypesSubstitutionRule;
          var substitutionRegExp = new RegExp(substitutionRule);
          if (substitutionRegExp.test(type)) {
            var substitutionNames = substitutionRegExp.exec(type);
            var substitutionName = substitutionNames[1];
            console.log(substitutionName);
            var allowedFakerTypesSubstitutionOptions = {
              type: 'input',
              name: substitutionName,
              message: 'Enter ' + substitutionName,
              default: '10'
            };
            var allowedFakerTypesSubstitutionCallback = function (answer) {
              var substitution = parseInt(answer[substitutionName]);
              type = type.replace(substitutionRegExp, "(" + substitution + ")");
              addFakeType(type);
              resolve(params);
            };
            _this.prompt(allowedFakerTypesSubstitutionOptions, allowedFakerTypesSubstitutionCallback);

          } else {
            addFakeType(type);
            resolve(params);
          }


        };
        _this.prompt(tablesColumnsFakerTypeModelFieldTypePromptOptions, tablesColumnsFakerTypeModelFieldTypePromptCallback);
      };
      return new Promise(tablesColumnsFakerTypeModelFieldTypePromiseFunc).then(tablesColumnsFakerTypeModelFieldsPrompt);
    };


//===========================UPDATE MODELS ALLOWED ATTRS=============

    var updateModelsAllowedAttrsPrompt = function () {
      var updateModelsAllowedAttrsPromiseFunc = function (resolve, reject) {
        var updateModelsAllowedAttrsPromptOptions = {
          type: 'list',
          name: 'model',
          message: 'Update models allowed fields \n Enter model name',
          choices: modelNames,
          default: modelNames[0]
        };
        var updateModelsAllowedAttrsPromptCallback = function (answers) {
          var modelName = answers.model;
          if (modelName != "none") {
            tablesColumnsFakerType[modelName] = {};
            var modelFields = Object.keys(models[modelName].columns);
            modelFields.push("none");
            resolve({modelName: modelName, modelFields: modelFields})
          } else {
            configObject['updateModelsAllowedAttrs'] = updateModelsAllowedAttrs;
            saveConfig();
            resolve(false);
          }
        };
        _this.prompt(updateModelsAllowedAttrsPromptOptions, updateModelsAllowedAttrsPromptCallback);
      };
      return new Promise(updateModelsAllowedAttrsPromiseFunc).then(afterUpdateModelsAllowedAttrsPrompt);
    };
    var afterUpdateModelsAllowedAttrsPrompt = function (params) {
      if (params) {
        return updateModelsAllowedAttrsFieldsPrompt(params);
      } else {
        return serverConfigPrompt();
      }
    };
    var updateModelsAllowedAttrsFieldsPrompt = function (params) {
      var updateModelsAllowedAttrsFieldsPromiseFunc = function (resolve, reject) {
        var updateModelsAllowedAttrsFieldsPromptOptions = {
          type: 'list',
          name: 'field',
          message: 'Enter field name',
          choices: params.modelFields,
          default: params.modelFields[0]
        };
        var updateModelsAllowedAttrsFieldsPromptCallback = function (answer) {
          var field = answer.field;
          params.field = field;
          if (field != "none") {
            if (!updateModelsAllowedAttrs[params.modelName])updateModelsAllowedAttrs[params.modelName] = [];
            updateModelsAllowedAttrs[params.modelName].push(field);
          }
          resolve(params);
        };
        _this.prompt(updateModelsAllowedAttrsFieldsPromptOptions, updateModelsAllowedAttrsFieldsPromptCallback);
      };
      return new Promise(updateModelsAllowedAttrsFieldsPromiseFunc).then(afterUpdateModelsAllowedAttrsFieldsPrompt);
    };
    var afterUpdateModelsAllowedAttrsFieldsPrompt = function (params) {
      if (params.field != "none") {
        return updateModelsAllowedAttrsFieldsPrompt(params);
      } else {
        return updateModelsAllowedAttrsPrompt();
      }
    };

//===========================SERVER CONFIG==================================

    var serverConfigPrompt = function () {
      var serverConfigPromiseFunc = function (resolve, reject) {
        var serverConfigPromptOptions = {
          type: 'input',
          name: 'host',
          message: 'Enter host',
          default: serverConfig.host || 'localhost'
        };
        var serverConfigPromptCallback = function (answer) {
          serverConfig.host = answer.host;
          resolve();
        };
        _this.prompt(serverConfigPromptOptions, serverConfigPromptCallback);
      };
      return new Promise(serverConfigPromiseFunc).then(serverConfigPortPrompt);
    };
    var serverConfigPortPrompt = function () {
      var serverConfigPortPromiseFunc = function (resolve, reject) {
        var serverConfigPortPromptOptions = {
          type: 'input',
          name: 'port',
          message: 'Enter port',
          default: serverConfig.port || '8080'
        };
        var serverConfigPortPromptCallback = function (answer) {
          serverConfig.port = answer.port;
          resolve();
        };
        _this.prompt(serverConfigPortPromptOptions, serverConfigPortPromptCallback);
      };
      return new Promise(serverConfigPortPromiseFunc).then(serverConfigProtocolPrompt);
    };
    var serverConfigProtocolPrompt = function () {
      var serverConfigProtocolPromiseFunc = function (resolve, reject) {
        var serverConfigProtocolPromptOptions = {
          type: 'list',
          name: 'protocol',
          message: 'Enter protocol',
          choices: ["http", "https"],
          default: serverConfig.protocol || 'http'
        };
        var serverConfigProtocolPromptCallback = function (answer) {
          serverConfig.protocol = answer.protocol;
          configObject["serverConfig"] = serverConfig;
          saveConfig();
          resolve();
        };
        _this.prompt(serverConfigProtocolPromptOptions, serverConfigProtocolPromptCallback);
      };
      return new Promise(serverConfigProtocolPromiseFunc).then(afterServerConfigPrompt);
    };
    var afterServerConfigPrompt = function () {
      return iosConfigPrompt();
    };

//======================================IOS CONFIG=================================
    var iosConfigPrompt = function () {
      var iosConfigPromiseFunc = function (resolve, reject) {
        var iosConfigPromptOptions = {
          type: 'input',
          name: 'name',
          message: 'Enter ios app name',
          default: iosConfig.appName || 'GeneratedProject'
        };
        var iosConfigPromptCallback = function (answer) {
          iosConfig.appName = answer.name;
          resolve();
        };
        _this.prompt(iosConfigPromptOptions, iosConfigPromptCallback);
      };
      return new Promise(iosConfigPromiseFunc).then(iosConfigPrefixPrompt);
    };
    var iosConfigPrefixPrompt = function () {
      var iosConfigPrefixPromiseFunc = function (resolve, reject) {
        var iosConfigPrefixPromptOptions = {
          type: 'input',
          name: 'prefix',
          message: 'Enter ios app prefix',
          default: iosConfig.appPrefix || 'GTP'
        };
        var iosConfigPrefixPromptCallback = function (answer) {
          iosConfig.appPrefix = answer.prefix.toUpperCase();
          configObject["iosConfig"] = iosConfig;
          saveConfig();
          resolve();
        };
        _this.prompt(iosConfigPrefixPromptOptions, iosConfigPrefixPromptCallback);
      };
      return new Promise(iosConfigPrefixPromiseFunc).then(afterIosConfigPromiseFunc);
    };
    var afterIosConfigPromiseFunc = function () {
      _this.log("That's it! Your config file has been generated!")
    };


    new Promise(generalPrompt)
        .then(modelPrompt);


  }


};

module.exports = generators.Base.extend(generatorObject);