/**
 * Created by yevhen_chmykhun on 13.10.15.
 */
var fs = require('fs');
var constants = require('./constants.json');

String.prototype.capitalizeFirstLetter = function () {
  return this.charAt(0).toUpperCase() + this.slice(1);
};
String.prototype.makeCamelCase = function () {
  return this.replace(/(_|-|\s)([a-z])/g, function (g) {
    return g[1].toUpperCase();
  });
};

String.prototype.makeUnderscore = function () {
  return this.replace(/([A-Z])/g, function (g) {
    return "_" + g.toLowerCase();
  }).replace(/(-|\s)/g, "_").replace(/^_/, "");
};

String.prototype.toPlural = function () {
  var i;
  var pluralEndings = constants.pluralEndings;
  var endings = Object.keys(pluralEndings);
  for (i = 0; i < endings.length; i++) {
    if (this.lastIndexOf(endings[i]) == this.length - endings[i].length) {
      return this.slice(0, this.length - endings[i].length) + pluralEndings[endings[i]];
    }
  }

  return this + "s";

};

exports.validateName = function (name) {
  var result = /^[a-zA-Z\s\-_]*$/.test(name) ||
      'Name must contain only letters';
  return result;
};

exports.validatePackageName = function (name) {
  var result = /^[a-zA-Z\s\-_\.]*$/.test(name) ||
    'Name must contain only letters';
  return result;
};

exports.validateColName = function(name){
  var result = exports.validateName(name);
  if(result === true){
    result = /^(^|_|\s|\-)+(id|iD|Id|ID)($|_|\s|\-)+$/.test(name) ?
      "column 'ID' is automatically created" : true;
  }
  return result;
};

exports.saveConfig = function (configObject, configFileName) {
  fs.writeFileSync(configFileName, JSON.stringify(configObject, null, 2), 'utf8');
};

exports.arrayIntersection = function (arr1, arr2) {
  var i;
  var result = [];
  var arr1Elements = {};
  var arr2Elements = {};
  for (i = 0; i < arr1.length; i++) arr1Elements[arr1[i]] = true;
  for (i = 0; i < arr2.length; i++) arr2Elements[arr2[i]] = true;
  for (var element in arr1Elements) arr2Elements[element] && result.push(element);
  return result;
};

//to make relation structure more convenient for CRUD creation

var initModelOrientedRelation = function (params, modelOrientedRelations) {
  initModelOrientedRelationRole(params, 'owner', modelOrientedRelations);
  initModelOrientedRelationRole(params, 'owned', modelOrientedRelations);
};
var initModelOrientedRelationRole = function (params, role, modelOrientedRelations) {
  var roleClassName = params.relationship[role + 'ClassName'];
  var relationType = params.rel;
  if (!modelOrientedRelations[roleClassName])
    modelOrientedRelations[roleClassName] = {};
  if (!modelOrientedRelations[roleClassName][relationType])
    modelOrientedRelations[roleClassName][relationType] = {};

  if (!modelOrientedRelations[roleClassName][relationType]['owner'])
    modelOrientedRelations[roleClassName][relationType]['owner'] = [];
  if (!modelOrientedRelations[roleClassName][relationType]['owned'])
    modelOrientedRelations[roleClassName][relationType]['owned'] = [];
};
exports.addModelOrientedRelation = function (params, modelOrientedRelations) {
  initModelOrientedRelation(params, modelOrientedRelations);
  var ownerClassName = params.relationship.ownerClassName;
  var ownedClassName = params.relationship.ownedClassName;
  var relationType = params.rel;
  //owned
  modelOrientedRelations[ownerClassName][relationType]['owned'].push(ownedClassName);
  //owner
  modelOrientedRelations[ownedClassName][relationType]['owner'].push(ownerClassName);


};


exports.InjectCRUDModelNames = function (params, type, modelOrientedRelations) {
  params[type] = params[type] || {};
  try {
    if (params[type].isCRUDModelNamesInjected) return;
    var i, j, k;
    var hints = constants.CRUDRelationTypesHints[type + 'NestedModels'];
    var hintRelRoles = Object.keys(hints);
    var allowedRelTypes = [];
    var modelsForInsertion = {};
    var allowedModels = ["none"];
    var currentModels = [];

    //role - owner or owned for relation
    for (i = 0; i < hintRelRoles.length; i++) {
      allowedRelTypes = Object.keys(hints[hintRelRoles[i]]);
      for (j = 0; j < allowedRelTypes.length; j++) {
        if (modelOrientedRelations[params.modelName]
            && modelOrientedRelations[params.modelName][allowedRelTypes[j]]
            && modelOrientedRelations[params.modelName][allowedRelTypes[j]][hintRelRoles[i]]) {
          currentModels = modelOrientedRelations[params.modelName][allowedRelTypes[j]][hintRelRoles[i]];
          for (k = 0; k < currentModels.length; k++) {
            if (currentModels[k]) {
              if (hints[hintRelRoles[i]] && hints[hintRelRoles[i]][allowedRelTypes[j]]) {
                modelsForInsertion[currentModels[k]] = hints[hintRelRoles[i]][allowedRelTypes[j]];
                if (allowedModels.indexOf(currentModels[k]) < 0)
                  allowedModels.push(currentModels[k]);
              }
            }
          }
        }
      }
    }
    params[type].isCRUDModelNamesInjected = true;
    params[type].modelsForInsertion = modelsForInsertion;
    params[type].allowedModels = allowedModels;
  } catch (err) {
    console.log('err in InjectCRUDModelNames: ', err);
  }

};

exports.replaceTempTypeToTrue = function (modelName, columnName, models) {
  var tempColumnTypes = constants.columnTempTypes;
  var tempType = models[modelName].columns[columnName].type;
  var trueType = tempColumnTypes[tempType];
  if (trueType) {
    models[modelName].columns[columnName].type = trueType;
  }
};

exports.generateFunctionForRule = function (ruleSign) {
  var ruleFunctionString = constants.ruleFunctionTemplate.replace("%rule%", ruleSign);
  return new Function('substitution', 'validation', ruleFunctionString);
};


exports.expandGenerator = function (generator) {


  generator.configFileName = 'someConfig.json';

  generator.configObject = {};
  generator.models = {};
  generator.relationships = {};
  generator.modelsCrudMethods = {};
  generator.tablesColumnsFakerType = {};
  generator.onlyServerFields = {};
  generator.updateModelsAllowedAttrs = {};
  generator.serverConfig = {};
  generator.iosConfig = {};

  generator.modelsCanBeUpdated = [];
  generator.modelsHaveUpdateAllowedAttrs = [];

  generator.modelNames = [];
  generator.pureModelNames = [];
  generator.relTypes = [];

  generator.tableColumnsToFake = [];

  generator.modelOrientedRelations = {};

  generator.minContent = false;

  generator.modelNames.push("none");
  for (var relationIndex = 0; relationIndex < constants.relationshipsTypes.length; relationIndex++) {
    generator.relTypes.push(constants.relationshipsTypes[relationIndex]);
    generator.relationships[constants.relationshipsTypes[relationIndex]] = [];
  }
  generator.relTypes.push("none");

};