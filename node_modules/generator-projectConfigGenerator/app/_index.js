/**
 * Created by yevhen_chmykhun on 29.09.15.
 */
var generators = require('yeoman-generator');
var fs = require('fs');
var constants = require('./constants.json');
var configObject = {};
var models = {};
var relationships = {};
var modelsCrudMethods = {};
var modelNames = [];
var pureModelNames = [];
modelNames.push("none");

var relTypes = [];
constants.relationshipsTypes.forEach(function (element) {
  relTypes.push(element);
});
relTypes.push("none");

var CRUDMethods = [];
constants.modelsCrudMethods.forEach(function (element) {
  CRUDMethods.push(element);
});
CRUDMethods.push("none");

function saveConfig() {
  fs.writeFileSync('someConfig.json', JSON.stringify(configObject, null, 2), 'utf8');
}

var generatorObject = {

  prompting: function () {
    var _this = this;


    var modelsCrudMethodsOptions = {
      type: 'list',
      name: 'model',
      message: 'Enter model for CRUD',
      choices: modelNames,
      default: modelNames[0]
    };
    var modelsCrudMethodsCallBack = function (answer) {
      var modelName = answer.model;
      if (modelName != "none") {
        modelsCrudMethods[modelName] = {};


        var crudMethodsProps = {
          type: 'list',
          name: 'methodName',
          message: 'Enter method for CRUD',
          choices: CRUDMethods,
          default: CRUDMethods[0]
        };
        var crudMethodsCallback = function (answer) {
          var methodName = answer.methodName;
          if (methodName != "none") {
            modelsCrudMethods[modelName][methodName] = {};

            var requestNestedModelsProp = {
              type: 'list',
              name: 'model',
              message: 'Enter request nested Model',
              choices: modelNames,
              default: modelNames[0]
            };
            var requestNestedModelsCallback = function (answer) {
              var requestNestedModelName = answer.model;
              if (!modelsCrudMethods[modelName][methodName]["requestNestedModels"]) {
                modelsCrudMethods[modelName][methodName]["requestNestedModels"] = {}
              }
              if (requestNestedModelName != "none") {
                var modelDataTypeProp = {
                  type: 'list',
                  name: 'modelType',
                  message: 'Enter request nested model type',
                  choices: constants.CRUDModelsTypes,
                  default: constants.CRUDModelsTypes[0]
                };
                var modelDataTypeCallback = function (answer) {
                  modelsCrudMethods[modelName][methodName]["requestNestedModels"][requestNestedModelName] = answer.modelType;
                  _this.prompt(requestNestedModelsProp, requestNestedModelsCallback);
                };
                _this.prompt(modelDataTypeProp, modelDataTypeCallback);

              } else {


                var responseNestedModelsProp = {
                  type: 'list',
                  name: 'model',
                  message: 'Enter response nested Model',
                  choices: modelNames,
                  default: modelNames[0]
                };
                var responseNestedModelsCallback = function (answer) {
                  var responseNestedModelName = answer.model;
                  if (!modelsCrudMethods[modelName][methodName]["responseNestedModels"]) {
                    modelsCrudMethods[modelName][methodName]["responseNestedModels"] = {}
                  }
                  if (responseNestedModelName != "none") {

                    var modelDataTypeProp = {
                      type: 'list',
                      name: 'modelType',
                      message: 'Enter response nested model type',
                      choices: constants.CRUDModelsTypes,
                      default: constants.CRUDModelsTypes[0]
                    };
                    var modelDataTypeCallback = function (answer) {
                      modelsCrudMethods[modelName][methodName]["responseNestedModels"][responseNestedModelName] = answer.modelType;
                      _this.prompt(responseNestedModelsProp, responseNestedModelsCallback);
                    };
                    _this.prompt(modelDataTypeProp, modelDataTypeCallback);

                  } else {
                    _this.prompt(modelsCrudMethodsOptions, modelsCrudMethodsCallBack);
                  }
                };
                _this.prompt(responseNestedModelsProp, responseNestedModelsCallback);


              }
            };

            _this.prompt(requestNestedModelsProp, requestNestedModelsCallback);


          } else {
            _this.prompt(modelsCrudMethodsOptions, modelsCrudMethodsCallBack);
          }
        };
        _this.prompt(crudMethodsProps, crudMethodsCallback);


      } else {
        configObject['modelsCrudMethods'] = modelsCrudMethods;
        //fs.writeFileSync('someConfig.json', JSON.stringify(configObject, null, 4), 'utf8');
        saveConfig();
        //_this.prompt(modelsCrudMethodsOptions, modelsCrudMethodsCallBack);
      }

    };


    var relationshipsPromptOptions = {
      type: 'list',
      name: 'type',
      message: 'Enter relationship type',
      choices: relTypes,
      default: relTypes[0]
    };

    var relationshipsPromptCallback = function (answers) {
      var rel = answers.type;
      if (rel != "none") {

        var ownerClassProp = {
          type: 'list',
          name: 'ownerClassName',
          message: 'Enter owner class name',
          choices: pureModelNames,
          default: pureModelNames[0]
        };
        var ownerClassCallback = function (answer) {
          var ownerClassName = answer.ownerClassName;
          var relationship = {
            ownerClassName: ownerClassName
          };
          var ownedClassProp = {
            type: 'list',
            name: 'ownedClassName',
            message: 'Enter owned class name',
            choices: pureModelNames,
            default: pureModelNames[0]
          };
          var ownedClassCallback = function (answer) {
            relationship.ownedClassName = answer.ownedClassName;
            var deleteOwnerConstraintProp = {
              type: 'list',
              name: 'onDeleteOwnerConstraint',
              message: 'delete owner constraint',
              choices: constants.onDeleteOwnerConstraints,
              default: constants.onDeleteOwnerConstraints[0]
            };
            var deleteOwnerConstraintCallback = function (answer) {
              if(answer.onDeleteOwnerConstraint != "none"){
                relationship.onDeleteOwnerConstraint = answer.onDeleteOwnerConstraint;
              }
              relationships[rel].push(relationship);

              _this.prompt(relationshipsPromptOptions, relationshipsPromptCallback);
            };
            _this.prompt(deleteOwnerConstraintProp, deleteOwnerConstraintCallback);


          };
          _this.prompt(ownedClassProp, ownedClassCallback);

        };
        _this.prompt(ownerClassProp, ownerClassCallback);
      } else {
        configObject['relationships'] = relationships;
        //fs.writeFileSync('someConfig.json', JSON.stringify(configObject, null, 4), 'utf8');
        saveConfig();
        _this.prompt(modelsCrudMethodsOptions, modelsCrudMethodsCallBack);
      }
    };





    var modelPromptOptions = {
      type: 'input',
      name: 'model',
      message: 'Enter model name',
      default: ''
    };
    var modelPromptCallback = function (answers) {
      _this.log(answers.model);
      modelNames.push(answers.model);
      pureModelNames.push(answers.model);
      if (answers.model != '') {
        var modelName = answers.model;
        models[modelName] = {};

        _this.prompt({
          type: 'input',
          name: 'table',
          message: 'Enter table name',
          default: answers.model.toLowerCase() + 's'
        }, function (answers) {
          models[modelName].table = answers.table;


          var columnNamePromptObj = {
            type: 'input',
            name: 'column',
            message: 'Enter column name',
            default: ''
          };
          var columnNameCallback = function (answers) {
            if (!models[modelName].columns) {
              models[modelName].columns = {};
            }
            if (answers.column != '') {
              var columnName = answers.column;
              models[modelName].columns[columnName] = {};
              var columnTypePromptObject = {
                type: 'list',
                name: 'type',
                message: 'Enter column type',
                choices: constants.columnTypes,
                default: constants.columnTypes[0]
              };

              var columnTypePromptCallback = function (answers) {
                var columnType = answers.type;

                models[modelName].columns[columnName].type = columnType;


                var isUniqueOptions = {
                  type: 'list',
                  name: 'isUnique',
                  message: 'Is this field unique?',
                  choices: ["no", "yes"],
                  default: "no"
                };
                var isUniqueCallback = function (answers) {

                  if (answers.isUnique == "yes") {
                    models[modelName].columns[columnName].unique = true;
                  }
                  _this.prompt(columnNamePromptObj, columnNameCallback);

                };

                var doValidateOptions = {
                  type: 'list',
                  name: 'doValidate',
                  message: 'Is there any validation rules?',
                  choices: ["no", "yes"],
                  default: "no"
                };
                var doValidateCallback = function (answers) {

                  if (answers.doValidate == "yes") {
                    models[modelName].columns[columnName].validate = {};

                    var validationTypeOptions = {
                      type: 'list',
                      name: 'validationType',
                      message: 'Enter validation type',
                      choices: constants.fieldValidateTypes,
                      default: constants.fieldValidateTypes[0]
                    };
                    var validationTypeCallback = function (answers) {

                      switch (answers.validationType) {
                        case 'len':
                          if (models[modelName].columns[columnName].type == "STRING") {
                            models[modelName].columns[columnName].validate.len = [];

                            var validationLenTypeOptions = {
                              type: 'input',
                              name: 'boundaryValues',
                              message: 'Enter boundary values, separated be comma(Ex: 8,22)',
                              default: '0,100'
                            };
                            var validationLenTypeCallback = function(answer){
                              var boundaryValues = answer.boundaryValues.split(',');
                              boundaryValues.forEach(function(element, index){
                                boundaryValues[index] = parseInt(element);
                              });
                              //if(boundaryValues.length == 1) boundaryValues = parseInt(boundaryValues);
                              models[modelName].columns[columnName].validate.len = boundaryValues;
                              _this.prompt(isUniqueOptions, isUniqueCallback);
                            };
                            _this.prompt(validationLenTypeOptions, validationLenTypeCallback);

                          } else {
                            _this.log("It's not possible!");
                            _this.prompt(isUniqueOptions, isUniqueCallback);
                          }
                          break;
                        case 'isInt':
                          if (constants.intTypes.indexOf(models[modelName].columns[columnName].type) >= 0) {
                            models[modelName].columns[columnName].validate.isInt = true;
                            _this.prompt(isUniqueOptions, isUniqueCallback);
                          } else {
                            _this.log("It's not possible!");
                            _this.prompt(isUniqueOptions, isUniqueCallback);
                          }
                          break;
                        default :
                          _this.log('How did i get here????');
                          _this.prompt(isUniqueOptions, isUniqueCallback);
                      }
                    };

                    _this.prompt(validationTypeOptions, validationTypeCallback);

                  }
                  else {
                    _this.prompt(isUniqueOptions, isUniqueCallback);
                  }

                };


                if (columnType == "STRING") {
                  var lengthPromptOptions = {
                    type: 'input',
                    name: 'fieldLength',
                    message: 'Enter length',
                    default: '255'
                  };
                  var lengthPromptCallback = function (answers) {
                    models[modelName].columns[columnName].length = parseInt(answers.fieldLength);

                    _this.prompt(doValidateOptions, doValidateCallback);

                  };
                  _this.prompt(lengthPromptOptions, lengthPromptCallback);
                } else {
                  _this.prompt(doValidateOptions, doValidateCallback);
                }


              };
              _this.prompt(columnTypePromptObject, columnTypePromptCallback);

            } else {

              var indexesPromptOptions = {
                type: 'list',
                name: 'indexType',
                message: 'Add index',
                choices: constants.indexesType,
                default: constants.indexesType[0]
              };
              var indexesPromptCallback = function(answers){
                var indexType = answers.indexType;
                if(indexType != "none"){
                  if(!models[modelName].indexes) models[modelName].indexes = [];
                  var index = {};
                  switch(indexType){
                    case "unique":
                      index.unique = true;
                      var fields = Object.keys(models[modelName].columns);
                      fields.push("none");
                      var fieldNamesForIndex = [];
                      var indexesFieldsPromptOptions = {
                        type: 'list',
                        name: 'fieldName',
                        message: 'Add fields for unique index',
                        choices: fields,
                        default: fields[0]
                      };
                      var indexesFieldsPromptCallback = function(answer){
                        var fieldName = answer.fieldName;
                        if(fieldName != "none"){
                          fieldNamesForIndex.push(fieldName);
                          _this.prompt(indexesFieldsPromptOptions, indexesFieldsPromptCallback);
                        }else{
                          index.fields = fieldNamesForIndex;
                          models[modelName].indexes.push(index);
                          _this.prompt(indexesPromptOptions, indexesPromptCallback);
                        }

                      };
                      _this.prompt(indexesFieldsPromptOptions, indexesFieldsPromptCallback);


                      break;
                    default :
                      _this.log('How did i get here????');
                      _this.prompt(modelPromptOptions, modelPromptCallback);
                  }
                }
                else{
                  _this.prompt(modelPromptOptions, modelPromptCallback);
                }

              };

              _this.prompt(indexesPromptOptions, indexesPromptCallback);

            }
          };


          _this.prompt(columnNamePromptObj, columnNameCallback);


        });


      } else {

        configObject['models'] = models;
        //fs.writeFileSync('someConfig.json', JSON.stringify(configObject, null, 4), 'utf8');
        saveConfig();
        configObject.relationships = {};
        constants.relationshipsTypes.forEach(function (element) {
          relationships[element] = [];
        });
        _this.prompt(relationshipsPromptOptions, relationshipsPromptCallback);
      }
    };










    var generalPromptOptions = {
      type: 'message',
      name: 'general',
      message: "wellcome to config generator. Press Enter to start"
    };
    var generalPromptCallback = function (answers) {
      _this.prompt(modelPromptOptions, modelPromptCallback);
    };


    _this.prompt(generalPromptOptions, generalPromptCallback);


  }


};

module.exports = generators.Base.extend(generatorObject);