/**
 * Created by yevhen_chmykhun on 13.10.15.
 */

var constants = require('./../constants.json');
var util = require('./../util');

module.exports = function (gen, next) {

  var generator = gen, nextPrompt = next;

  var modelsCRUDMethodsPrompt = function () {
    var modelsCRUDMethodsPromiseFunc = function (resolve, reject) {
      var modelsCRUDMethodsPromptOptions = {
        type: 'list',
        name: 'model',
        message: 'Enter model for CRUD(none to proceed)',
        choices: generator.modelNames,
        default: generator.modelNames[0]
      };
      var modelsCRUDMethodsPromptOptionsCallback = function (answers) {
        var modelName = answers.model;
        if (modelName == "none") {
          generator.configObject['modelsCrudMethods'] = generator.modelsCrudMethods;
          util.saveConfig(generator.configObject, generator.configFileName);
          resolve(false);
        }
        else {
          resolve({modelName: modelName})
        }
      };
      generator.prompt(modelsCRUDMethodsPromptOptions, modelsCRUDMethodsPromptOptionsCallback);
    };
    return new Promise(modelsCRUDMethodsPromiseFunc).then(afterModelsCRUDMethodsPrompt);
  };


  var afterModelsCRUDMethodsPrompt = function (params) {
    if (params) {
      return CRUDMethodsPrompt(params);
    } else {
      return nextPrompt ? nextPrompt() : false;
    }
  };


  var CRUDMethodsPrompt = function (params) {
    var CRUDMethodsPromiseFunc = function (resolve, reject) {
      var CRUDMethodsPromptOptions = {
        type: 'list',
        name: 'methodNameKey',
        message: 'Enter method for CRUD(none to proceed)',
        choices: constants.modelsCrudMethodsKeys,
        default: constants.modelsCrudMethodsKeys[0]
      };
      var CRUDMethodsPromptCallback = function (answers) {
        var methodNameKey = answers.methodNameKey;
        if (!generator.modelsCrudMethods[params.modelName]) generator.modelsCrudMethods[params.modelName] = {};
        if (methodNameKey != "none") {
          if (!generator.modelsCrudMethods[params.modelName]) generator.modelsCrudMethods[params.modelName] = {};
          var methodName = constants.modelsCrudMethods[methodNameKey];
          generator.modelsCrudMethods[params.modelName][methodName] = {};
          params.methodName = methodName;
          resolve(params);
        } else {
          resolve(false);
        }
      };
      generator.prompt(CRUDMethodsPromptOptions, CRUDMethodsPromptCallback);
    };
    return new Promise(CRUDMethodsPromiseFunc).then(afterCRUDMethodsPrompt);
  };
  var afterCRUDMethodsPrompt = function (params) {
    if (!params) {
      return modelsCRUDMethodsPrompt();
    } else {
      return requestNestedModelsPrompt(params);
    }
  };

  var nestedModelsPromiseFuncGenerator = function (params, type) {
    return function (resolve, reject) {
      if (!generator.modelsCrudMethods[params.modelName][params.methodName][type + "NestedModels"]) {
        generator.modelsCrudMethods[params.modelName][params.methodName][type + "NestedModels"] = {}
      }
      if (params.methodName == "DELETE" || (params.methodName == "GET" && type == "request")) {
        params[type + "NestedModelName"] = "none";
        resolve(params);
        return;
      }
      if (params.methodName == "PUT") {
        //adding info that this model must have at least one updatable field
        if (generator.modelsCanBeUpdated.indexOf(params.modelName) < 0) generator.modelsCanBeUpdated.push(params.modelName);
      }
      util.InjectCRUDModelNames(params, type, generator.modelOrientedRelations);
      var requestNestedModelsPromptOptions = {
        type: 'list',
        name: 'model',
        message: 'Enter ' + type + ' nested Model',
        choices: params[type].allowedModels,
        default: params[type].allowedModels[0]
      };
      var requestNestedModelsPromptCallback = function (answers) {
        params[type + "NestedModelName"] = answers.model;
        if (params[type + "NestedModelName"] != "none") {
          generator.modelsCrudMethods[params.modelName]
              [params.methodName]
              [type + "NestedModels"]
              [answers.model] = params[type].modelsForInsertion[answers.model];
        }
        resolve(params);
      };
      generator.prompt(requestNestedModelsPromptOptions, requestNestedModelsPromptCallback);
    };
  };

  var requestNestedModelsPrompt = function (params) {
    var requestNestedModelsPromiseFunc = nestedModelsPromiseFuncGenerator(params, "request");
    return new Promise(requestNestedModelsPromiseFunc).then(afterRequestNestedModelsPromiseFunc);
  };
  var afterRequestNestedModelsPromiseFunc = function (params) {
    if (params.requestNestedModelName != "none") {
      //return requestModelCRUDDataTypePrompt(params)
      return requestNestedModelsPrompt(params);
    } else {
      return responseNestedModelsPrompt(params);
    }
  };
  var requestModelCRUDDataTypePrompt = function (params) {
    var requestModelCRUDDataTypePromiseFunction = function (resolve, reject) {
      var requestModelCRUDDataTypePromptOptions = {
        type: 'list',
        name: 'modelType',
        message: 'Enter request nested model type',
        choices: constants.CRUDModelsTypes,
        default: constants.CRUDModelsTypes[0]
      };
      var requestModelCRUDDataTypePromptCallback = function (answers) {
        generator.modelsCrudMethods[params.modelName][params.methodName]["requestNestedModels"][params.requestNestedModelName] = answers.modelType;
        resolve(params);
      };
      generator.prompt(requestModelCRUDDataTypePromptOptions, requestModelCRUDDataTypePromptCallback);
    };
    return new Promise(requestModelCRUDDataTypePromiseFunction).then(requestNestedModelsPrompt);
  };
  var responseNestedModelsPrompt = function (params) {
    var responseNestedModelsPromiseFunc = nestedModelsPromiseFuncGenerator(params, "response");
    return new Promise(responseNestedModelsPromiseFunc).then(afterResponseNestedModelsPromiseFunc);
  };
  var afterResponseNestedModelsPromiseFunc = function (params) {
    if (params.responseNestedModelName != "none") {
      //return responseModelCRUDDataTypePrompt(params)
      return responseNestedModelsPrompt(params)
    } else {
      return modelsCRUDMethodsPrompt(params);
    }
  };
  var responseModelCRUDDataTypePrompt = function (params) {
    var responseModelCRUDDataTypePromiseFunction = function (resolve, reject) {
      var responseModelCRUDDataTypePromptOptions = {
        type: 'list',
        name: 'modelType',
        message: 'Enter response nested model type',
        choices: constants.CRUDModelsTypes,
        default: constants.CRUDModelsTypes[0]
      };
      var responseModelCRUDDataTypePromptCallback = function (answers) {
        generator.modelsCrudMethods[params.modelName][params.methodName]["responseNestedModels"][params.responseNestedModelName] = answers.modelType;
        resolve(params);
      };
      generator.prompt(responseModelCRUDDataTypePromptOptions, responseModelCRUDDataTypePromptCallback);
    };
    return new Promise(responseModelCRUDDataTypePromiseFunction).then(responseNestedModelsPrompt);
  };

  return modelsCRUDMethodsPrompt;
};