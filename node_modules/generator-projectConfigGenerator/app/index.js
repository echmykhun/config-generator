/**
 * Created by yevhen_chmykhun on 29.09.15.
 */
var generators = require('yeoman-generator');
var fs = require('fs');
var constants = require('./constants.json');
var configObject = {};
var models = {};
var relationships = {};
var modelsCrudMethods = {};
var tablesColumnsFakerType = {};
var onlyServerFields = {};
var updateModelsAllowedAttrs = {};
var serverConfig = {};
var iosConfig = {};

var modelNames = [];
var pureModelNames = [];
var relTypes = [];
var CRUDMethods = [];

modelNames.push("none");
constants.relationshipsTypes.forEach(function (element) {
  relTypes.push(element);
});
relTypes.push("none");
constants.modelsCrudMethods.forEach(function (element) {
  CRUDMethods.push(element);
});
CRUDMethods.push("none");
constants.relationshipsTypes.forEach(function (element) {
  relationships[element] = [];
});

function saveConfig() {
  fs.writeFileSync('someConfig.json', JSON.stringify(configObject, null, 2), 'utf8');
}

var generatorObject = {

  prompting: function () {
    var _this = this;


    var generalPrompt = function (resolve, reject) {
      var generalPromptOptions = {
        type: 'input',
        name: 'name',
        message: "Wellcome to config generator. \n Enter your app name and press Enter to start"
      };
      var generalPromptCallback = function (answers) {
        configObject.appName = answers.name;
        saveConfig();
        resolve();
      };
      _this.prompt(generalPromptOptions, generalPromptCallback);
    };

//==========================MODELS======================================
    var modelPromptPromiseFunc = function (resolve, reject) {
      var modelPromptOptions = {
        type: 'input',
        name: 'model',
        message: 'Enter model name',
        default: ''
      };
      var modelPromptCallback = function (answers) {
        if (answers.model != '') {
          modelNames.push(answers.model);
          pureModelNames.push(answers.model);
          var modelName = answers.model;
          models[modelName] = {};
          resolve(modelName)
        } else {
          configObject['models'] = models;
          saveConfig();
          resolve(false)
        }
      };
      _this.prompt(modelPromptOptions, modelPromptCallback);
    };
    var modelPrompt = function (val) {
      return new Promise(modelPromptPromiseFunc).then(afterModelPrompt);
    };
    var afterModelPrompt = function (modelName) {
      if (modelName) {
        return tableNamePrompt(modelName);
      } else {
        return relationsPrompt();
      }
    };
    var tableNamePrompt = function (modelName) {
      var tableNamePromptPromiseFunc = function (resolve, reject) {
        var tableNamePromptOptions = {
          type: 'input',
          name: 'table',
          message: 'Enter table name',
          default: modelName.toLowerCase() + 's'
        };
        var tableNamePromptCallback = function (answers) {
          var tableName = answers.table;
          models[modelName].table = tableName;
          resolve(modelName);
        };
        _this.prompt(tableNamePromptOptions, tableNamePromptCallback);
      };
      return new Promise(tableNamePromptPromiseFunc).then(columnNamePrompt);
    };
    var columnNamePrompt = function (modelName) {
      if (typeof modelName == 'object') modelName = modelName.modelName;
      var columnNamePromptPromiseFunc = function (resolve, reject) {
        var columnNamePromptOptions = {
          type: 'input',
          name: 'column',
          message: 'Enter column name',
          default: ''
        };
        var columnNameCallback = function (answers) {
          if (!models[modelName].columns) {
            models[modelName].columns = {};
          }
          if (answers.column != '') {
            var columnName = answers.column;
            models[modelName].columns[columnName] = {};
            resolve({modelName: modelName, columnName: columnName})
          } else {
            resolve({modelName: modelName, columnName: false})
          }
        };
        _this.prompt(columnNamePromptOptions, columnNameCallback);
      };
      return new Promise(columnNamePromptPromiseFunc).then(afterColumnNamePrompt);
    };
    var afterColumnNamePrompt = function (params) {
      var columnTypePromiseFunc = function (resolve, reject) {
        var columnTypePromptOptions = {
          type: 'list',
          name: 'type',
          message: 'Enter column type',
          choices: constants.columnTypes,
          default: constants.columnTypes[0]
        };

        var columnTypePromptCallback = function (answers) {
          var columnType = answers.type;
          models[params.modelName].columns[params.columnName].type = columnType;
          if (columnType == "STRING") {
            var lengthPromptOptions = {
              type: 'input',
              name: 'fieldLength',
              message: 'Enter length',
              default: '255'
            };
            var lengthPromptCallback = function (answers) {
              models[params.modelName].columns[params.columnName].length = parseInt(answers.fieldLength);
              resolve({modelName: params.modelName, columnName: params.columnName})
            };
            _this.prompt(lengthPromptOptions, lengthPromptCallback);
          } else {
            resolve({modelName: params.modelName, columnName: params.columnName})
          }
        };
        _this.prompt(columnTypePromptOptions, columnTypePromptCallback);
      };
      var indexesPromiseFunc = function (resolve, reject) {
        function indexSwitch(indexType, index) {
          switch (indexType) {
            case "unique":
              index.unique = true;
              var fields = Object.keys(models[params.modelName].columns);
              fields.push("none");
              var fieldNamesForIndex = [];
              var indexesFieldsPromptOptions = {
                type: 'list',
                name: 'fieldName',
                message: 'Add fields for unique index',
                choices: fields,
                default: fields[0]
              };
              var indexesFieldsPromptCallback = function (answer) {
                var fieldName = answer.fieldName;
                if (fieldName != "none") {
                  fieldNamesForIndex.push(fieldName);
                  _this.prompt(indexesFieldsPromptOptions, indexesFieldsPromptCallback);
                } else {
                  index.fields = fieldNamesForIndex;
                  models[params.modelName].indexes.push(index);
                  _this.prompt(indexesPromptOptions, indexesPromptCallback);
                }

              };
              _this.prompt(indexesFieldsPromptOptions, indexesFieldsPromptCallback);
              break;
            default :
              _this.log('How did i get here????');
              resolve(false);
          }
        }

        var indexesPromptOptions = {
          type: 'list',
          name: 'indexType',
          message: 'Add index',
          choices: constants.indexesType,
          default: constants.indexesType[0]
        };
        var indexesPromptCallback = function (answers) {
          var indexType = answers.indexType;
          if (indexType != "none") {
            if (!models[params.modelName].indexes) models[params.modelName].indexes = [];
            var index = {};
            indexSwitch(indexType, index);
          }
          else {
            resolve(false);
          }

        };
        _this.prompt(indexesPromptOptions, indexesPromptCallback);

      };
      if (!params.columnName) return new Promise(indexesPromiseFunc).then(modelPrompt);
      return new Promise(columnTypePromiseFunc).then(columnDoValidatePrompt);
    };
    var columnDoValidatePrompt = function (params) {
      var columnDoValidatePromiseFunc = function (resolve, reject) {
        var columnDoValidatePromptOptions = {
          type: 'list',
          name: 'doValidate',
          message: 'Is there any validation rules?',
          choices: ["no", "yes"],
          default: "no"
        };
        var columnDoValidatePromptCallback = function (answers) {
          if (answers.doValidate == "yes") {
            models[params.modelName].columns[params.columnName].validate = {};

          }
          resolve({
            modelName: params.modelName,
            columnName: params.columnName,
            doValidate: answers.doValidate
          });
        };
        _this.prompt(columnDoValidatePromptOptions, columnDoValidatePromptCallback);
      };
      return new Promise(columnDoValidatePromiseFunc).then(columnValidationTypesPrompt);
    };
    var columnValidationTypesPrompt = function (params) {

      var columnIsUniquePromiseFunc = function (resolve, reject) {
        var columnIsUniquePromptOptions = {
          type: 'list',
          name: 'isUnique',
          message: 'Is this field unique?',
          choices: ["no", "yes"],
          default: "no"
        };
        var columnIsUniquePromptCallback = function (answers) {
          if (answers.isUnique == "yes") {
            models[params.modelName].columns[params.columnName].unique = true;
          }
          resolve(params.modelName)
        };
        _this.prompt(columnIsUniquePromptOptions, columnIsUniquePromptCallback);
      };
      var columnIsUniquePrompt = function (params) {
        return new Promise(columnIsUniquePromiseFunc).then(columnNamePrompt)
      };


      var columnValidationTypesPromiseFunc = function (resolve, reject) {

        function launchLengthValidationSetupPrompt() {
          var validationLenTypeOptions = {
            type: 'input',
            name: 'boundaryValues',
            message: 'Enter boundary values, separated be comma(Ex: 8,22)',
            default: '0,100'
          };
          var validationLenTypeCallback = function (answer) {
            var boundaryValues = answer.boundaryValues.split(',');
            boundaryValues.forEach(function (element, index) {
              boundaryValues[index] = parseInt(element);
            });
            models[params.modelName].columns[params.columnName].validate.len = boundaryValues;
            resolve(params);
          };
          _this.prompt(validationLenTypeOptions, validationLenTypeCallback);
        }

        var columnValidationTypesPromptOptions = {
          type: 'list',
          name: 'validationType',
          message: 'Enter validation type',
          choices: constants.fieldValidateTypes,
          default: constants.fieldValidateTypes[0]
        };
        var columnValidationTypesPromptCallback = function (answers) {

          switch (answers.validationType) {
            case 'len':
              if (models[params.modelName].columns[params.columnName].type == "STRING") {
                models[params.modelName].columns[params.columnName].validate.len = [];
                launchLengthValidationSetupPrompt();
              } else {
                _this.log("It's not possible!");
                resolve(params);
              }
              break;
            case 'isInt':
              if (constants.intTypes.indexOf(models[params.modelName].columns[params.columnName].type) >= 0) {
                models[params.modelName].columns[params.columnName].validate.isInt = true;
                resolve(params);
              } else {
                _this.log("It's not possible!");
                resolve(params);
              }
              break;
            default :
              _this.log('How did i get here????');
              resolve(params);
          }


        };
        _this.prompt(columnValidationTypesPromptOptions, columnValidationTypesPromptCallback);
      };

      if (params.doValidate == "no") {
        return new Promise(columnIsUniquePromiseFunc).then(columnNamePrompt);
      } else {

        return new Promise(columnValidationTypesPromiseFunc).then(columnIsUniquePrompt);
      }

      //return new Promise(columnValidationTypesPromiseFunc);//.then(columnIsUniquePrompt);
    };

//========================RELATIONS================
    var relationsPrompt = function () {
      var relationsPromptPromiseFunc = function (resolve, reject) {
        var relationsPromptOptions = {
          type: 'list',
          name: 'type',
          message: 'Enter relationship type',
          choices: relTypes,
          default: relTypes[0]
        };
        var relationsPromptCallback = function (answers) {
          var rel = answers.type;
          if (rel == "none") {
            configObject['relationships'] = relationships;
            saveConfig();
          }
          resolve(rel);
        };
        _this.prompt(relationsPromptOptions, relationsPromptCallback);

      };
      return new Promise(relationsPromptPromiseFunc).then(afterRelationsPrompt);
    };
    var afterRelationsPrompt = function (rel) {
      if (rel != "none") {
        var params = {rel: rel};
        return ownerClassPropPrompt(params);
      } else {
        return modelsCRUDMethodsPrompt();
      }
    };
    var ownerClassPropPrompt = function (params) {
      var ownerClassPropPromiseFunc = function (resolve, reject) {
        var ownerClassPropPromptOptions = {
          type: 'list',
          name: 'ownerClassName',
          message: 'Enter owner class name',
          choices: pureModelNames,
          default: pureModelNames[0]
        };
        var ownerClassPropPromptCallback = function (answers) {
          params.relationship = {};
          params.relationship.ownerClassName = answers.ownerClassName;
          resolve(params)
        };
        _this.prompt(ownerClassPropPromptOptions, ownerClassPropPromptCallback);

      };
      return new Promise(ownerClassPropPromiseFunc).then(ownedClassPropPrompt);
    };
    var ownedClassPropPrompt = function (params) {
      var ownedClassPropPromiseFunc = function (resolve, reject) {
        var ownedClassPropPromptOptions = {
          type: 'list',
          name: 'ownedClassName',
          message: 'Enter owned class name',
          choices: pureModelNames,
          default: pureModelNames[0]
        };
        var ownedClassPropPromptCallback = function (answers) {
          params.relationship.ownedClassName = answers.ownedClassName;
          resolve(params)
        };
        _this.prompt(ownedClassPropPromptOptions, ownedClassPropPromptCallback);

      };
      return new Promise(ownedClassPropPromiseFunc).then(deleteOwnerConstraintsPrompt);
    };
    var deleteOwnerConstraintsPrompt = function (params) {
      var deleteOwnerConstraintsPromiseFunc = function (resolve, reject) {
        var deleteOwnerConstraintsPromptOptions = {
          type: 'list',
          name: 'onDeleteOwnerConstraint',
          message: 'delete owner constraint',
          choices: constants.onDeleteOwnerConstraints,
          default: constants.onDeleteOwnerConstraints[0]
        };
        var deleteOwnerConstraintsPromptCallback = function (answers) {
          if (answers.onDeleteOwnerConstraint != "none") {
            params.relationship.onDeleteOwnerConstraint = answers.onDeleteOwnerConstraint;
          }
          relationships[params.rel].push(params.relationship);
          resolve(false);
        };

        _this.prompt(deleteOwnerConstraintsPromptOptions, deleteOwnerConstraintsPromptCallback);
      };
      return new Promise(deleteOwnerConstraintsPromiseFunc).then(relationsPrompt);
    };

//==========================CRUD============

    var modelsCRUDMethodsPrompt = function () {
      var modelsCRUDMethodsPromiseFunc = function (resolve, reject) {
        var modelsCRUDMethodsPromptOptions = {
          type: 'list',
          name: 'model',
          message: 'Enter model for CRUD',
          choices: modelNames,
          default: modelNames[0]
        };
        var modelsCRUDMethodsPromptOptionsCallback = function (answers) {
          var modelName = answers.model;
          if (modelName == "none") {
            configObject['modelsCrudMethods'] = modelsCrudMethods;
            saveConfig();
            resolve(false);
          }
          else {
            resolve({modelName: modelName})
          }
        };
        _this.prompt(modelsCRUDMethodsPromptOptions, modelsCRUDMethodsPromptOptionsCallback);
      };
      return new Promise(modelsCRUDMethodsPromiseFunc).then(afterModelsCRUDMethodsPrompt);
    };
    var afterModelsCRUDMethodsPrompt = function (params) {
      if (params) {
        return CRUDMethodsPrompt(params);
      } else {
        return onlyServerFieldsPrompt();
      }
    };
    var CRUDMethodsPrompt = function (params) {
      var CRUDMethodsPromiseFunc = function (resolve, reject) {
        var CRUDMethodsPromptOptions = {
          type: 'list',
          name: 'methodName',
          message: 'Enter method for CRUD',
          choices: CRUDMethods,
          default: CRUDMethods[0]
        };
        var CRUDMethodsPromptCallback = function (answers) {
          var methodName = answers.methodName;
          if (!modelsCrudMethods[params.modelName])modelsCrudMethods[params.modelName] = {};
          if (methodName != "none") {
            modelsCrudMethods[params.modelName][methodName] = {};
            params.methodName = methodName;
            resolve(params);
          } else {
            resolve(false);
          }
        };
        _this.prompt(CRUDMethodsPromptOptions, CRUDMethodsPromptCallback);
      };
      return new Promise(CRUDMethodsPromiseFunc).then(afterCRUDMethodsPrompt);
    };
    var afterCRUDMethodsPrompt = function (params) {
      if (!params) {
        return modelsCRUDMethodsPrompt();
      } else {
        return requestNestedModelsPrompt(params);
      }
    };
    var requestNestedModelsPrompt = function (params) {
      var requestNestedModelsPromiseFunc = function (resolve, reject) {
        var requestNestedModelsPromptOptions = {
          type: 'list',
          name: 'model',
          message: 'Enter request nested Model',
          choices: modelNames,
          default: modelNames[0]
        };
        var requestNestedModelsPromptCallback = function (answers) {
          var requestNestedModelName = answers.model;
          if (!modelsCrudMethods[params.modelName][params.methodName]["requestNestedModels"]) {
            modelsCrudMethods[params.modelName][params.methodName]["requestNestedModels"] = {}
          }
          params.requestNestedModelName = requestNestedModelName;
          resolve(params);
        };
        _this.prompt(requestNestedModelsPromptOptions, requestNestedModelsPromptCallback);
      };
      return new Promise(requestNestedModelsPromiseFunc).then(afterRequestNestedModelsPromiseFunc);
    };
    var afterRequestNestedModelsPromiseFunc = function (params) {
      if (params.requestNestedModelName != "none") {
        return requestModelCRUDDataTypePrompt(params)
      } else {
        return responseNestedModelsPrompt(params);
      }
    };
    var requestModelCRUDDataTypePrompt = function (params) {
      var requestModelCRUDDataTypePromiseFunction = function (resolve, reject) {
        var requestModelCRUDDataTypePromptOptions = {
          type: 'list',
          name: 'modelType',
          message: 'Enter request nested model type',
          choices: constants.CRUDModelsTypes,
          default: constants.CRUDModelsTypes[0]
        };
        var requestModelCRUDDataTypePromptCallback = function (answers) {
          modelsCrudMethods[params.modelName][params.methodName]["requestNestedModels"][params.requestNestedModelName] = answers.modelType;
          resolve(params);
        };
        _this.prompt(requestModelCRUDDataTypePromptOptions, requestModelCRUDDataTypePromptCallback);
      };
      return new Promise(requestModelCRUDDataTypePromiseFunction).then(requestNestedModelsPrompt);
    };
    var responseNestedModelsPrompt = function (params) {
      var responseNestedModelsPromiseFunc = function (resolve, reject) {
        var responseNestedModelsPromptOptions = {
          type: 'list',
          name: 'model',
          message: 'Enter response nested Model',
          choices: modelNames,
          default: modelNames[0]
        };
        var responseNestedModelsPromptCallback = function (answers) {
          var responseNestedModelName = answers.model;
          if (!modelsCrudMethods[params.modelName][params.methodName]["responseNestedModels"]) {
            modelsCrudMethods[params.modelName][params.methodName]["responseNestedModels"] = {}
          }
          params.responseNestedModelName = responseNestedModelName;
          resolve(params);
        };
        _this.prompt(responseNestedModelsPromptOptions, responseNestedModelsPromptCallback);
      };
      return new Promise(responseNestedModelsPromiseFunc).then(afterResponseNestedModelsPromiseFunc);
    };
    var afterResponseNestedModelsPromiseFunc = function (params) {
      if (params.responseNestedModelName != "none") {
        return responseModelCRUDDataTypePrompt(params)
      } else {
        return modelsCRUDMethodsPrompt(params);
      }
    };
    //нужно будет вынести в общий, чуть позже этим займусь
    var responseModelCRUDDataTypePrompt = function (params) {
      var responseModelCRUDDataTypePromiseFunction = function (resolve, reject) {
        var responseModelCRUDDataTypePromptOptions = {
          type: 'list',
          name: 'modelType',
          message: 'Enter response nested model type',
          choices: constants.CRUDModelsTypes,
          default: constants.CRUDModelsTypes[0]
        };
        var responseModelCRUDDataTypePromptCallback = function (answers) {
          modelsCrudMethods[params.modelName][params.methodName]["responseNestedModels"][params.responseNestedModelName] = answers.modelType;
          resolve(params);
        };
        _this.prompt(responseModelCRUDDataTypePromptOptions, responseModelCRUDDataTypePromptCallback);
      };
      return new Promise(responseModelCRUDDataTypePromiseFunction).then(responseNestedModelsPrompt);
    };

//==========================ONLY SERVER FIELD=======================


    var onlyServerFieldsPrompt = function () {
      var onlyServerFieldsPromiseFunc = function (resolve, reject) {
        var onlyServerFieldsPromptOptions = {
          type: 'list',
          name: 'model',
          message: 'Only server fields \n Enter model name',
          choices: modelNames,
          default: modelNames[0]
        };
        var onlyServerFieldsPromptCallback = function (answers) {
          var modelName = answers.model;
          if (modelName != "none") {
            tablesColumnsFakerType[modelName] = {};
            var modelFields = Object.keys(models[modelName].columns);
            modelFields.push("none");
            resolve({modelName: modelName, modelFields: modelFields})
          } else {
            configObject['onlyServerFields'] = onlyServerFields;
            saveConfig();
            resolve(false);
          }
        };
        _this.prompt(onlyServerFieldsPromptOptions, onlyServerFieldsPromptCallback);
      };
      return new Promise(onlyServerFieldsPromiseFunc).then(afterOnlyServerFieldsPrompt);
    };
    var afterOnlyServerFieldsPrompt = function (params) {
      if (params) {
        return onlyServerFieldsModelFieldsPrompt(params);
      } else {
        return tablesColumnsFakerTypePrompt();
      }
    };
    var onlyServerFieldsModelFieldsPrompt = function (params) {
      var onlyServerFieldsModelFieldsPromiseFunc = function (resolve, reject) {
        var onlyServerFieldsModelFieldsPromptOptions = {
          type: 'list',
          name: 'field',
          message: 'Enter field name',
          choices: params.modelFields,
          default: params.modelFields[0]
        };
        var onlyServerFieldsModelFieldsPromptCallback = function (answer) {
          var field = answer.field;
          params.field = field;
          if (field != "none") {
            if (!onlyServerFields[params.modelName])onlyServerFields[params.modelName] = [];
            onlyServerFields[params.modelName].push(field);
          }
          resolve(params);
        };
        _this.prompt(onlyServerFieldsModelFieldsPromptOptions, onlyServerFieldsModelFieldsPromptCallback);
      };
      return new Promise(onlyServerFieldsModelFieldsPromiseFunc).then(afterOnlyServerFieldsModelFieldsPrompt);
    };
    var afterOnlyServerFieldsModelFieldsPrompt = function (params) {
      if (params.field != "none") {
        return onlyServerFieldsModelFieldsPrompt(params);
      } else {
        return onlyServerFieldsPrompt();
      }
    };

//==========================TABLES COLUMNS FAKER TYPE================

    var tablesColumnsFakerTypePrompt = function () {
      var tablesColumnsFakerTypePromiseFunc = function (resolve, reject) {
        var tablesColumnsFakerTypePromptOptions = {
          type: 'list',
          name: 'model',
          message: 'TABLES COLUMNS FAKER TYPE \n Enter model name',
          choices: modelNames,
          default: modelNames[0]
        };
        var tablesColumnsFakerTypePromptCallback = function (answers) {
          var modelName = answers.model;
          if (modelName != "none") {
            tablesColumnsFakerType[modelName] = {};
            var modelFields = Object.keys(models[modelName].columns);
            modelFields.push("none");
            resolve({modelName: modelName, modelFields: modelFields})
          } else {
            configObject['tablesColumnsFakerType'] = tablesColumnsFakerType;
            saveConfig();
            resolve(false);
          }
        };
        _this.prompt(tablesColumnsFakerTypePromptOptions, tablesColumnsFakerTypePromptCallback);
      };
      return new Promise(tablesColumnsFakerTypePromiseFunc).then(afterTablesColumnsFakerTypePrompt);
    };
    var afterTablesColumnsFakerTypePrompt = function (params) {
      if (params) {
        return tablesColumnsFakerTypeModelFieldsPrompt(params);
      } else {
        return updateModelsAllowedAttrsPrompt();
      }
    };
    var tablesColumnsFakerTypeModelFieldsPrompt = function (params) {
      var tablesColumnsFakerTypeModelFieldsPromiseFunc = function (resolve, reject) {
        var tablesColumnsFakerTypeModelFieldsPromptOptions = {
          type: 'list',
          name: 'field',
          message: 'Enter field name',
          choices: params.modelFields,
          default: params.modelFields[0]
        };
        var tablesColumnsFakerTypeModelFieldsPromptCallback = function (answers) {
          if (answers.field != "none") {
            params.field = answers.field;
            resolve(params);
          } else {
            resolve(false);
          }
        };
        _this.prompt(tablesColumnsFakerTypeModelFieldsPromptOptions, tablesColumnsFakerTypeModelFieldsPromptCallback);
      };
      return new Promise(tablesColumnsFakerTypeModelFieldsPromiseFunc).then(afterTablesColumnsFakerTypeModelFieldsPrompt);
    };
    var afterTablesColumnsFakerTypeModelFieldsPrompt = function (params) {
      if (params) {
        return tablesColumnsFakerTypeModelFieldTypePrompt(params)
      } else {
        return tablesColumnsFakerTypePrompt();
      }
    };
    var tablesColumnsFakerTypeModelFieldTypePrompt = function (params) {
      var tablesColumnsFakerTypeModelFieldTypePromiseFunc = function (resolve, reject) {
        var tablesColumnsFakerTypeModelFieldTypePromptOptions = {
          type: 'list',
          name: 'fieldType',
          message: 'Enter field type',
          choices: constants.allowedFakerTypes,
          default: constants.allowedFakerTypes[0]
        };
        var tablesColumnsFakerTypeModelFieldTypePromptCallback = function (answer) {
          var type = answer.fieldType;

          if (constants.allowedFakerTypesLength.indexOf(type) >= 0) {
            var allowedFakerTypesLengthOptions = {
              type: 'input',
              name: 'length',
              message: 'Enter length',
              default: '10'
            };
            var allowedFakerTypesLengthCallback = function (answer) {
              var length = parseInt(answer.length);
              type = type.replace("(length)", "(" + length + ")");
              if (!tablesColumnsFakerType[models[params.modelName].table])
                tablesColumnsFakerType[models[params.modelName].table] = {};
              tablesColumnsFakerType[models[params.modelName].table][params.field] = type;
              resolve(params);
            };
            _this.prompt(allowedFakerTypesLengthOptions, allowedFakerTypesLengthCallback);

          } else {
            if (!tablesColumnsFakerType[models[params.modelName].table])
              tablesColumnsFakerType[models[params.modelName].table] = {};
            tablesColumnsFakerType[models[params.modelName].table][params.field] = type;
            resolve(params);
          }


        };
        _this.prompt(tablesColumnsFakerTypeModelFieldTypePromptOptions, tablesColumnsFakerTypeModelFieldTypePromptCallback);
      };
      return new Promise(tablesColumnsFakerTypeModelFieldTypePromiseFunc).then(tablesColumnsFakerTypeModelFieldsPrompt);
    };


//===========================UPDATE MODELS ALLOWED ATTRS=============

    var updateModelsAllowedAttrsPrompt = function () {
      var updateModelsAllowedAttrsPromiseFunc = function (resolve, reject) {
        var updateModelsAllowedAttrsPromptOptions = {
          type: 'list',
          name: 'model',
          message: 'Update models allowed fields \n Enter model name',
          choices: modelNames,
          default: modelNames[0]
        };
        var updateModelsAllowedAttrsPromptCallback = function (answers) {
          var modelName = answers.model;
          if (modelName != "none") {
            tablesColumnsFakerType[modelName] = {};
            var modelFields = Object.keys(models[modelName].columns);
            modelFields.push("none");
            resolve({modelName: modelName, modelFields: modelFields})
          } else {
            configObject['updateModelsAllowedAttrs'] = updateModelsAllowedAttrs;
            saveConfig();
            resolve(false);
          }
        };
        _this.prompt(updateModelsAllowedAttrsPromptOptions, updateModelsAllowedAttrsPromptCallback);
      };
      return new Promise(updateModelsAllowedAttrsPromiseFunc).then(afterUpdateModelsAllowedAttrsPrompt);
    };
    var afterUpdateModelsAllowedAttrsPrompt = function (params) {
      if (params) {
        return updateModelsAllowedAttrsFieldsPrompt(params);
      } else {
        return serverConfigPrompt();
      }
    };
    var updateModelsAllowedAttrsFieldsPrompt = function (params) {
      var updateModelsAllowedAttrsFieldsPromiseFunc = function (resolve, reject) {
        var updateModelsAllowedAttrsFieldsPromptOptions = {
          type: 'list',
          name: 'field',
          message: 'Enter field name',
          choices: params.modelFields,
          default: params.modelFields[0]
        };
        var updateModelsAllowedAttrsFieldsPromptCallback = function (answer) {
          var field = answer.field;
          params.field = field;
          if (field != "none") {
            if (!updateModelsAllowedAttrs[params.modelName])updateModelsAllowedAttrs[params.modelName] = [];
            updateModelsAllowedAttrs[params.modelName].push(field);
          }
          resolve(params);
        };
        _this.prompt(updateModelsAllowedAttrsFieldsPromptOptions, updateModelsAllowedAttrsFieldsPromptCallback);
      };
      return new Promise(updateModelsAllowedAttrsFieldsPromiseFunc).then(afterUpdateModelsAllowedAttrsFieldsPrompt);
    };
    var afterUpdateModelsAllowedAttrsFieldsPrompt = function (params) {
      if (params.field != "none") {
        return updateModelsAllowedAttrsFieldsPrompt(params);
      } else {
        return updateModelsAllowedAttrsPrompt();
      }
    };

//===========================SERVER CONFIG==================================

    var serverConfigPrompt = function(){
      var serverConfigPromiseFunc = function(resolve, reject){
        var serverConfigPromptOptions = {
          type: 'input',
          name: 'host',
          message: 'Enter host',
          default: 'localhost'
        };
        var serverConfigPromptCallback = function(answer){
          serverConfig.host = answer.host;
          resolve();
        };
        _this.prompt(serverConfigPromptOptions, serverConfigPromptCallback);
      };
      return new Promise(serverConfigPromiseFunc).then(serverConfigPortPrompt);
    };
    var serverConfigPortPrompt = function(){
      var serverConfigPortPromiseFunc = function(resolve, reject){
        var serverConfigPortPromptOptions = {
          type: 'input',
          name: 'port',
          message: 'Enter port',
          default: '8080'
        };
        var serverConfigPortPromptCallback = function(answer){
          serverConfig.port = answer.port;
          resolve();
        };
        _this.prompt(serverConfigPortPromptOptions, serverConfigPortPromptCallback);
      };
      return new Promise(serverConfigPortPromiseFunc).then(serverConfigProtocolPrompt);
    };
    var serverConfigProtocolPrompt = function(){
      var serverConfigProtocolPromiseFunc = function(resolve, reject){
        var serverConfigProtocolPromptOptions = {
          type: 'list',
          name: 'protocol',
          message: 'Enter protocol',
          choices: ["http", "https"],
          default: 'http'
        };
        var serverConfigProtocolPromptCallback = function(answer){
          serverConfig.protocol = answer.protocol;
          configObject["serverConfig"] = serverConfig;
          saveConfig();
          resolve();
        };
        _this.prompt(serverConfigProtocolPromptOptions, serverConfigProtocolPromptCallback);
      };
      return new Promise(serverConfigProtocolPromiseFunc).then(afterServerConfigPrompt);
    };
    var afterServerConfigPrompt = function(){
      return iosConfigPrompt();
    };

//======================================IOS CONFIG=================================
    var iosConfigPrompt = function(){
      var iosConfigPromiseFunc = function(resolve, reject){
        var iosConfigPromptOptions = {
          type: 'input',
          name: 'name',
          message: 'Enter ios app name',
          default: ''
        };
        var iosConfigPromptCallback = function(answer){
          iosConfig.appName = answer.name;
          resolve();
        };
        _this.prompt(iosConfigPromptOptions, iosConfigPromptCallback);
      };
      return new Promise(iosConfigPromiseFunc).then(iosConfigPrefixPrompt);
    };

    var iosConfigPrefixPrompt = function(){
      var iosConfigPrefixPromiseFunc = function(resolve, reject){
        var iosConfigPrefixPromptOptions = {
          type: 'input',
          name: 'prefix',
          message: 'Enter ios app prefix',
          default: ''
        };
        var iosConfigPrefixPromptCallback = function(answer){
          iosConfig.appPrefix = answer.prefix.toUpperCase();
          configObject["iosConfig"] = iosConfig;
          saveConfig();
          resolve();
        };
        _this.prompt(iosConfigPrefixPromptOptions, iosConfigPrefixPromptCallback);
      };
      return new Promise(iosConfigPrefixPromiseFunc).then(afterIosConfigPromiseFunc);
    };
    var afterIosConfigPromiseFunc = function(){
      _this.log("That's it! Your config file has been generated!")
    };




    new Promise(generalPrompt)
        .then(modelPrompt);


  }


};

module.exports = generators.Base.extend(generatorObject);